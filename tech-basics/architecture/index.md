# アーキテクチャ・設計

### スケールアウト（Scale-out） / スケールイン（Scale-in）
サーバーの台数を増やして処理を分散するのがスケールアウト。<br>逆に台数を減らしてコストを下げるのがスケールイン。<br>

メリット： 同時接続数や並列処理能力を簡単に伸ばせる。可用性（冗長化）も向上する。<br>
注意点： セッション管理やデータ整合性、設定の同期が必要になることが多い。

---

### スケールアップ（Scale-up） / スケールダウン（Scale-down）
既存のサーバー自体のCPUやメモリ、ディスク容量を増やして性能を上げるのがスケールアップ。<br>逆にリソースを下げるのがスケールダウン。<br>

メリット： 単純に処理性能を上げやすく、アプリ側の設計変更が少ない場合がある。<br>
注意点： 物理的・インスタンスの上限があり、スケールアウトほど柔軟でない。ダウンタイムが発生する可能性がある。

---

### フェイルオーバー（Failover）
システム障害が発生した際に、自動的に予備系（待機系）のサーバーやシステムに切り替えて、サービスを継続する仕組み。<br>
「障害時の自動切り替え」と理解すればよい。<br>

**主な目的:** 可用性の向上（システムを止めないこと）。障害発生時のダウンタイムを最小化する。<br>

**フェイルオーバーの構成例:**<br>
```
アクティブ・スタンバイ構成（ホットスタンバイ）:
┌─────────┐
│サーバーA│  
│(稼働中) │   障害発生！
└─────────┘ 
 ↓ 切り替え         
┌─────────┐
│サーバーB│
│(待機中) │ → 稼働開始
└─────────┘


アクティブ・アクティブ構成:
┌─────────┐
│サーバーA│ ← 両方とも稼働中
│(稼働中) │    負荷分散
└─────────┘
┌─────────┐
│サーバーB│ ← Aが落ちても
│(稼働中) │    Bが全て処理
└─────────┘
```

**スケールアウトとの違い:**<br>

| 項目 | スケールアウト | フェイルオーバー |
|------|---------------|------------------|
| **主な目的** | 性能向上・負荷分散 | 可用性向上・障害対策 |
| **サーバーの役割** | 全台が常に稼働して負荷分散 | 予備系は待機（または軽負荷） |
| **障害時の動作** | 残りのサーバーで処理継続 | 予備系へ自動切り替え |
| **導入理由** | 「遅い」を解決 | 「止まらない」を実現 |

**重要な違い:**<br>
- **スケールアウト**: 複数サーバーが同時に処理して性能を上げる。結果的に1台落ちても大丈夫だが、本来の目的は「速くすること」。<br>
- **フェイルオーバー**: 障害時に切り替えることが目的。性能向上は副次的効果。<br>

**実際の関係性:**<br>
スケールアウト構成（複数サーバー）を組むと、自然とフェイルオーバー能力も得られることが多い。<br>
しかし、フェイルオーバーのために必ずしもスケールアウトが必要なわけではない（アクティブ・スタンバイ構成は2台だけ）。<br>

**使われる場面:**<br>
- データベースサーバー（マスター・スレーブ構成）<br>
- Webサーバー（ロードバランサー配下で自動切り替え）<br>
- ネットワーク機器（ルーター、ファイアウォールの冗長化）<br>
- クラウドサービス（AWSのMulti-AZ、Azureの可用性セット）<br>

**フェイルバック:**<br>
障害が復旧した後、元の主系（サーバーA）に戻す作業をフェイルバックという。<br>
自動で戻す場合もあれば、手動で戻す場合もある。<br>

---

### クラスタ構成（クラスター）／クラスタリング
複数のサーバーやノードを**1つのまとまり（クラスター）として連携させる構成**。<br>
アクティブ・アクティブでもアクティブ・スタンバイでも、外からは「1つのサービス」として見える設計。<br>
**性能向上・可用性・運用性など、複合的な目的**で導入されることが多い。<br>

**よくある目的:**<br>
- **可用性**（止まらない）を上げる<br>
- **性能**（さばける量）を上げる<br>
- **運用性**（メンテしやすい）を上げる<br>

**代表的なクラスタの形:**<br>
- **アクティブ・アクティブ**: 全台稼働で負荷分散（性能向上に強い）<br>
- **アクティブ・スタンバイ**: 片方稼働・片方待機（可用性重視）<br>

**スケールアウトとの関係:**<br>
- クラスタ構成は**複数台で動かす「仕組み」**<br>
- スケールアウトは**台数を増やす「手段」**<br>
→ つまり、スケールアウトはクラスタリングの一部として行われることが多い。<br>

**フェイルオーバーとの関係:**<br>
- クラスタ構成の中に**フェイルオーバー機能**が含まれることが多い（自動切り替え）。<br>

**冗長化との違い:**<br>
- **冗長化**: 基本的に**可用性（止まらない）目的が中心**。性能向上は主目的ではない。<br>
- **クラスタ構成**: 可用性だけでなく、**性能向上や負荷分散も含む**設計。<br>

**「クラスタ○○」の読み方:**<br>
クラスタDB、クラスタストレージなど「クラスタ○○」と呼ばれる場合、<br>
**複数台で構成された○○（HA・性能・負荷分散など複合的な目的）** という意味。<br>
単純な冗長化だけでなく、性能面の向上も含む場合が多い。<br>

**使われる場面:**<br>
- Webサーバーの冗長化（ロードバランサー配下）<br>
- データベースの冗長化（クラスタDB）<br>
- 共有ストレージの冗長化<br>

**注意点:**<br>
- セッション共有やデータ同期など、**複数台で整合性を保つ設計**が必要。<br>
- 構成が複雑になる分、運用コストは上がりやすい。<br>

「複数台で1つのシステムを作る考え方」そのものがクラスタ構成。<br>

---

### DevOps（デブオプス）
Development（開発）とOperations（運用）を組み合わせた造語。<br>
開発チームと運用チームの協力を促進する管理体制・文化・手法の総称。<br>
特定のサービスやツールではなく、組織運営の考え方や哲学を指す。<br>

**従来の問題:** 開発と運用が分離されていて、コミュニケーション不足や対立が発生。<br>
**DevOpsの解決策:** チーム間の壁を取り払い、共通目標に向けて協力する文化を醸成。<br>

**実践例:** CI/CD（自動テスト・自動デプロイ）、監視・フィードバック、アジャイル開発<br>
**関連ツール:** Azure DevOps、Jenkins、Docker、Kubernetesなど（ツール自体がDevOpsではない）<br>

---

### UAT環境（User Acceptance Test／ユーエーティー環境）
**別名:** 受け入れ環境、ユーザー受入テスト環境、承認環境<br>

User Acceptance Testの略。<br>
本番リリース前にユーザー（または発注者・利用部門）が最終確認を行うための検証環境。<br>
開発したシステムが要件を満たしているか、実際の業務で使えるかを確認する最終ステップ。

**環境の流れ（あくまで一般的な例）:**<br>
```
開発環境 → STG環境 → UAT環境 → 本番環境
(Dev)      (STG)    (UAT)    (Production)
```

**UAT環境の特徴:**<br>
- 本番と同じ構成・データで実施されることが多い<br>
- ユーザーが実際の業務フローで動作確認<br>
- ここで承認されて初めて本番リリースへ進む<br>
- 開発チームではなく、発注者側やエンドユーザーが主体<br>

**ステージング環境との違い:**<br>

| 項目 | ステージング環境 | UAT環境 |
|------|-----------------|---------|
| **主な目的** | 技術的な最終動作確認・リハーサル | ユーザーによる業務受け入れテスト |
| **誰が使う** | 開発チーム・運用チーム | エンドユーザー・発注者 |
| **確認内容** | 本番と同じ動作をするか | 業務要件を満たすか |
| **位置づけ** | デプロイ前の最終検証 | 承認のための環境 |

**現場での運用パターン:**<br>
- **パターン1**: ステージング環境とUAT環境が別々に存在（大規模プロジェクト）<br>
- **パターン2**: 同じ環境をステージング・UAT両方の用途で使用（中小規模）<br>
- **パターン3**: ステージング→UAT の順に同じ環境で実施<br>

UAT環境は、本番一歩手前の「最終関門」として機能する重要な環境。<br>

---

### クラウドサービスの4層構造（IaaS、PaaS、SaaS、IPaaS）
クラウドサービスを「どこまでクラウド事業者が管理してくれるか」で分類した構造。<br>
下層ほど利用者の管理範囲が広く、上層ほどクラウド事業者が多くを管理してくれる。<br>

**IaaS（Infrastructure as a Service）:** 仮想的なハードウェアを提供。仮想サーバー（VM）、仮想ネットワークなど。<br>
例: Azure Virtual Machines、AWS EC2、Azure Virtual Network<br>

**PaaS（Platform as a Service）:** アプリケーション実行環境を提供。OSやミドルウェアは管理不要。<br>
例: Azure App Service、Azure Container Apps、AWS Lambda<br>

**SaaS（Software as a Service）:** 完成したソフトウェアをそのまま利用。<br>
例: Microsoft 365、Gmail、Salesforce<br>

**IPaaS（Integration Platform as a Service）:** システム間連携を簡単にするツールを提供。<br>
例: Azure Logic Apps、AWS Step Functions<br>

---

### アーキテクチャとは
「アーキテクチャ」というとシステム開発におけるシステム全体の構造や設計方針を示す。<br>
「どのような構造でシステムを作るか」という大きな設計思想のこと。<br>

**階層イメージ:**<br>
```
システムアーキテクチャ（最上位）
├── インフラアーキテクチャ（サーバー、ネットワーク構成）
├── ソフトウェアアーキテクチャ（アプリケーションの構造）
├── データアーキテクチャ（データの流れ、DB設計）
└── セキュリティアーキテクチャ（認証、暗号化など）
```
上記のように、各層で異なるアーキテクチャが存在する。<br>
「アーキテクチャ ≒ 設計方針」と理解してよい。<br>

**具体例（ECサイトを作る場合）:**<br>

**アーキテクチャレベル（全体方針）:**<br>
- 「マイクロサービスアーキテクチャで作る」<br>
- 「3層アーキテクチャで作る」<br>

**↓ これを実現するための各設計:**<br>

**インフラ設計:**<br>
- AWSを使う<br>
- ロードバランサー配下にWebサーバー3台<br>
- RDS（データベース）はMulti-AZ構成<br>

**ソフトウェア設計:**<br>
- MVCパターンで実装<br>
- ビジネスロジックはDDDで設計<br>
- APIはRESTful設計<br>

**データ設計:**<br>
- ユーザー情報はRDB<br>
- 商品画像はS3<br>
- セッションはRedis<br>

**実務での使われ方:**<br>
文脈によって意味が変わる。<br>
- 「システムアーキテクチャを決める」→ 全体構造の方針決定（最上位）<br>
- 「クリーンアーキテクチャで設計する」→ ソフトウェアの構造パターン<br>
- 「インフラアーキテクチャ図を描く」→ インフラ構成の設計<br>

---

### システムアーキテクチャパターン
システム全体の構成・構造を決定するパターン。<br>
インフラとアプリケーション全体をどう組み立てるかの方針。<br>

**レイヤードアーキテクチャ（階層化アーキテクチャ）/ 3層アーキテクチャ:**<br>
システムを階層に分けて構築する最も基本的な構造。<br>
プレゼンテーション層（画面）、ビジネスロジック層（業務処理）、データアクセス層（DB）に分ける。<br>
各層は下の層にのみ依存し、明確に責任が分離される。<br>

**マイクロサービスアーキテクチャ:**<br>
システムを小さな独立したサービスに分割し、それぞれが独自のデータベースを持つ。<br>
各サービスは独立してデプロイ可能。Netflix、Amazonなどが採用。<br>
利点：独立したスケーリング、技術スタックの自由度、障害の局所化<br>
課題：サービス間通信の複雑さ、分散トランザクション、運用の難しさ<br>

**モノリシックアーキテクチャ:**<br>
すべての機能が1つのアプリケーションにまとまった構造。<br>
マイクロサービスの対義語。小規模〜中規模のシステムでは十分に実用的。<br>
利点：シンプル、デプロイが容易、トランザクション管理が簡単<br>
課題：大規模化すると変更の影響範囲が広く、スケーリングが全体単位になる<br>

---

### ソフトウェアアーキテクチャパターン
アプリケーション内部の構造やコードの組み立て方に関するパターン。<br>
ビジネスロジックをどう設計するかの指針。<br>

**クリーンアーキテクチャ:**<br>
依存関係を内側（ビジネスロジック）に向ける設計思想。<br>
外部技術（DBやフレームワーク）に依存しないため、テストしやすく、変更に強い。<br>
ビジネスルールを中心に据え、インフラやUIは外側に配置する。<br>
同心円状の層構造で、内側の層は外側の層を知らない。<br>

**ヘキサゴナルアーキテクチャ（ポート&アダプター）:**<br>
六角形の中心にビジネスロジック、外側に入出力を配置する考え方。<br>
クリーンアーキテクチャと似た思想で、ビジネスロジックを技術的な詳細から隔離する。<br>
ポート（インターフェース）とアダプター（実装）で外部との接続を抽象化。<br>

**MVC（Model-View-Controller）:**<br>
データ（Model）、表示（View）、制御（Controller）を分離する設計パターン。<br>
Webアプリケーションで広く使われる。Ruby on Rails、ASP.NET MVCなどで採用。<br>
利点：役割分担が明確、並行開発しやすい、テストしやすい<br>

---

### 設計原則
良いソフトウェアを作るための基本的な指針・原則。<br>

**SOLID原則:**<br>
オブジェクト指向設計の5つの基本原則。<br>
- **S**: Single Responsibility（単一責任の原則）- 1つのクラスは1つの責務だけを持つ<br>
- **O**: Open/Closed（開放閉鎖の原則）- 拡張に対して開いていて、修正に対して閉じている<br>
- **L**: Liskov Substitution（リスコフの置換原則）- 派生クラスは基底クラスと置き換え可能<br>
- **I**: Interface Segregation（インターフェース分離の原則）- クライアントに不要なインターフェースを強制しない<br>
- **D**: Dependency Inversion（依存性逆転の原則）- 具象ではなく抽象に依存する<br>

**DRY（Don't Repeat Yourself）:**<br>
同じコードを繰り返し書かない。重複を避け、再利用可能なコードを書く。<br>
「知識や意図の重複」を避けることが本質。<br>

**YAGNI（You Aren't Gonna Need It）:**<br>
今必要ない機能は実装しない。過剰な設計を避け、シンプルに保つ。<br>
アジャイル開発において重要な考え方。<br>

**KISS（Keep It Simple, Stupid）:**<br>
シンプルに保つ。複雑な設計よりもシンプルで理解しやすい設計を優先する。<br>

**冪等性（べきとうせい / Idempotency）:**<br>
同じ操作を何度実行しても、結果が同じになる性質。<br>
**API設計やシステム設計において超重要な概念**。<br>

**わかりやすい例:**<br>
- ✅ **冪等**: 「ユーザーID=123を削除」→ 何度実行しても結果は同じ（1回目で削除済み、2回目以降は何も起きない）<br>
- ❌ **非冪等**: 「ユーザーを新規作成」→ 実行するたびに新しいユーザーが作られる<br>

**HTTPメソッドの冪等性:**<br>

| メソッド | 冪等性 | 理由 |
|---------|-------|------|
| **GET** | ✅ 冪等 | データを取得するだけ。何度実行しても同じ結果 |
| **PUT** | ✅ 冪等 | 指定リソースを更新。同じ内容で何度実行しても結果は同じ |
| **DELETE** | ✅ 冪等 | 指定リソースを削除。1回目で削除済み、2回目以降は変化なし |
| **POST** | ❌ 非冪等 | 新規作成。実行するたびに新しいリソースができる |
| **PATCH** | △ ケースバイケース | 部分更新。実装次第で冪等にも非冪等にもなる |

**重要な補足:**<br>
上記は**REST APIの設計思想・慣習**であり、技術的な強制ではない。<br>
実際の冪等性は**アプリケーションの実装次第**で決まる。<br>
- POSTでも request_id をチェックすれば冪等に実装可能<br>
- PUTでも実装が間違っていれば非冪等になる<br>

ただし、**RESTの規約に従う方が設計意図が明確**になる。<br>
- POST `/api/orders` → 「新しい注文を作って」（新規作成が期待される）<br>
- PUT `/api/orders/abc-123` → 「abc-123という注文を作成/更新して」（同じ結果が期待される）<br>

**実務での重要性:**<br>

**1. リトライ処理の安全性**<br>
ネットワークエラーや一時的な障害が起きた時、処理を再実行（リトライ）することがある。<br>
- 冪等な処理 → 何度リトライしても安全<br>
- 非冪等な処理 → リトライすると重複が発生する危険<br>

```
【例】決済処理でタイムアウト発生
❌ 非冪等（POST /payment）: リトライすると二重決済の危険
✅ 冪等（PUT /payment/abc123）: 同じ決済IDで何度実行しても安全
```

**2. 分散システムでの整合性**<br>
分散システムやマイクロサービスでは、ネットワーク障害でメッセージが重複送信されることがある。<br>
冪等性があれば、重複メッセージを受け取っても問題ない。<br>

**3. 障害復旧・ロールバック**<br>
システム障害から復旧する際、どこまで処理が進んだか不明な場合がある。<br>
冪等性があれば、安全に処理を再実行できる。<br>

**冪等性を実現する設計パターン:**<br>
- **一意なトランザクションID（リクエストID）を使う**: 同じIDのリクエストは2回目以降無視またはキャッシュ返却<br>
- **PUT/DELETEを使う**: RESTの慣習に従い、リソースを直接指定する設計にする<br>
- **状態チェック**: 処理前に「すでに実行済みか」を確認する（例: 注文が既に存在するか）<br>
- **バージョン管理**: 楽観的ロック（Optimistic Lock）でデータのバージョンを管理<br>

**重要:** どの方法も**サーバー側の実装で制御**する。HTTPメソッド自体が冪等性を保証するわけではない。<br>

**具体的な実装例（API設計）:**<br>

**パターン1: 非冪等な設計（一般的なPOST）**<br>
```
POST /api/orders
{ "item_id": 123, "quantity": 1 }

設計意図: 「新しい注文を作って」
結果: 実行するたびに新しい注文が作られる（非冪等）
問題: リトライすると重複注文が発生する
```

**パターン2: 冪等な設計（POST + リクエストID）**<br>
```
POST /api/orders
{ "request_id": "abc-123", "item_id": 123, "quantity": 1 }

設計意図: 「request_id=abc-123 の注文を作って」
実装: サーバー側で request_id をチェック。同じIDなら2回目以降は無視またはキャッシュを返す
結果: 何度実行しても同じ注文1つだけ（冪等）

◎ メリット: 技術的には冪等にできる。既存のPOSTエンドポイントに追加しやすい
△ 注意点: RESTの慣習的には「POST = 新規作成」なので意味がやや曖昧になる
```

**パターン3: 冪等な設計（PUT）**<br>
```
PUT /api/orders/abc-123
{ "item_id": 123, "quantity": 1 }

設計意図: 「abc-123という注文を作成/更新して」
実装: 指定されたIDの注文が存在しなければ作成、存在すれば更新（または何もしない）
結果: 何度実行しても注文abc-123は同じ状態（冪等）

◎ メリット: RESTの設計思想に沿っている。「リソースを指定して作成/更新」という意図が明確
△ 注意点: クライアント側が事前にIDを生成する必要がある（UUID等）
```

**結論:**<br>
- **技術的には**: POST でも PUT でもアプリ実装で冪等性を制御できる<br>
- **設計思想としては**: PUT の方が「特定リソースの作成/更新」という意図が明確<br>
- **実務では**: 
  - 既存システム: POST + request_id が導入しやすい<br>
  - 新規設計: PUT でリソース指定する設計が推奨<br>
  - どちらでも、サーバー側で重複チェックの実装が必須<br>

**よくある質問:**<br>
Q: POST + request_id と PUT の違いは？<br>
A: 機能的にはほぼ同じ。違いは「RESTの意味論」と「URLの構造」。<br>
   - POST `/api/orders` → 「注文を作って」（コレクションに追加）<br>
   - PUT `/api/orders/abc-123` → 「abc-123を作成/更新して」（リソースを直接指定）<br>

**注意点:**<br>
- 冪等性は「結果が同じ」であって「副作用が全くない」という意味ではない<br>
- GETは冪等だが、アクセスログは残る（完全に何も起きないわけではない）<br>
- DELETEは2回目以降「404 Not Found」を返す場合もあるが、リソースの状態は同じなので冪等<br>

**まとめ:**<br>
- 冪等性は「再実行しても安全」という保証<br>
- API設計、リトライ処理、障害対策で必須の考え方<br>
- HTTPメソッドの冪等性は「REST設計思想」であり、実際は**実装次第**<br>
- POST でも冪等に実装可能だが、PUT の方が設計意図が明確<br>
- サーバー側で重複チェックや状態管理の実装が必要<br>

---

### デザインパターン（GoFパターン）
GoF（Gang of Four：4人組）が定義した**23種類のオブジェクト指向設計パターン**。<br>
よくある設計問題に対する再利用可能な解決策のカタログ。<br>

**生成に関するパターン（Creational Patterns）:**<br>
オブジェクトの生成方法に関するパターン。<br>
- **シングルトン（Singleton）**: クラスのインスタンスを1つだけに制限<br>
- **ファクトリー（Factory Method）**: オブジェクト生成をサブクラスに委譲<br>
- **ビルダー（Builder）**: 複雑なオブジェクトを段階的に構築<br>

**構造に関するパターン（Structural Patterns）:**<br>
クラスやオブジェクトの構造に関するパターン。<br>
- **アダプター（Adapter）**: 互換性のないインターフェースをつなぐ<br>
- **デコレーター（Decorator）**: オブジェクトに動的に機能を追加<br>
- **ファサード（Facade）**: 複雑なサブシステムへのシンプルなインターフェースを提供<br>

**振る舞いに関するパターン（Behavioral Patterns）:**<br>
オブジェクト間の責任分担や協調動作に関するパターン。<br>
- **オブザーバー（Observer）**: オブジェクトの状態変化を他のオブジェクトに通知<br>
- **ストラテジー（Strategy）**: アルゴリズムを切り替え可能にする<br>
- **テンプレートメソッド（Template Method）**: アルゴリズムの骨組みを定義し、詳細はサブクラスで実装<br>

**学習の順番:**<br>
初心者はまず「シングルトン」「ファクトリー」「オブザーバー」「ストラテジー」あたりから学ぶと実用的。<br>
すべてを暗記する必要はなく、必要に応じて調べて使えば良い。<br>
