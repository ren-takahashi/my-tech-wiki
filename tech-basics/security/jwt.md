# JWTまとめ

## 1. JWTとは
JWT（JSON Web Token）は、  
**トークン（データ）のフォーマット（形式・仕様）**。  

**重要: JWT自体は認証の仕組みではなく、認証に使われる「データの入れ物」**  

JWTは以下のような用途で使われる：
- サーバーが「ユーザー認証に成功した」という情報をJWT形式のトークンとして発行  
- そのトークンをクライアントが持ち回り、APIにアクセスする時に提出  
- APIサーバー側は「トークンに押されたハンコ（署名）が正しいか」をチェックして利用者を認識  

**JWTのメリット:**  
- **自己完結型（Self-contained）**: トークン自体に情報が含まれている  
- **署名による改ざん検知**: データが改ざんされていないか確認できる  
- **ステートレス**: サーバー側でセッション情報を保持する必要がない  

JWTは単なるデータ形式なので、**認証の仕組み自体は別途実装が必要**（後述）。  

---

## 2. JWTの構造（フォーマット仕様）
JWTは3つのパートをドット（`.`）で繋いだ形式：

```
Header.Payload.Signature
```

- **Header（ヘッダー）** : トークンのタイプとアルゴリズム情報（例: `{"alg":"HS256","typ":"JWT"}`）  
- **Payload（ペイロード）** : 実際のデータ（ユーザーID、有効期限など。例: `{"userId":123,"exp":1234567890}`）  
  - Base64エンコードされているだけで**暗号化ではない**（誰でも読める）
  - 機密情報（パスワード、クレカ番号）は入れない
- **Signature（署名）** : Header + Payload を秘密鍵で計算した結果（＝電子的なハンコ）  
  - 改ざん検知用（データが変更されると署名が一致しなくなる）

**署名アルゴリズム:**  
- **対称鍵方式（HS256など）**: 同じ秘密鍵で署名と検証を行う  
- **非対称鍵方式（RS256など）**: 秘密鍵で署名、公開鍵で検証（より安全）  

署名の計算方法は公開されているが、**秘密鍵が漏れなければ署名は偽造できない**。  

---

## 3. すでにあるAPIにJWTを使った認証を導入する具体例
「画面ソースから呼ばれるAPIに、JWTを使った認証を入れたい」場合の流れ。

**前提: JWTはデータ形式なので、認証の仕組み全体を設計・実装する必要がある**

### 1. 全体像
- 認証用のAPI（例: `/login`）を作る  
- ユーザー認証成功時（ID/PWをDB照合）に、サーバーが秘密鍵で署名したJWTを発行  
- クライアントはそのJWTをCookieやLocalStorageに保存  
- 以降のAPIリクエストにはJWTを添付  
- サーバーはJWTの署名を検証し、Payloadから情報を取り出して処理を実行  

### 2. 認証フェーズ
```
Client → POST /login (ID/PW)
Server → JWT発行（署名済み）
```

### 3. リクエストフェーズ
```
Client → GET /api/resource (Authorization: Bearer {JWT})
Server → JWTを秘密鍵で検証 → OKなら処理
```

### 4. バックエンドでやること
- **認証処理**（ログイン時にID/PWをDB照合）
- **JWT発行処理**（認証成功時に秘密鍵で署名したJWTを生成）  
- **JWT検証処理**（API呼び出し時に署名を検証し、改ざんチェック）  
- **認可処理**（Payloadから取り出したuserIdなどで権限確認）

### 5. フロントでやること
- JWTを安全に保存（**HttpOnly Cookie推奨**、またはLocalStorage）  
- API呼び出し時にJWTをAuthorizationヘッダに付与  
  例: `Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...`  

### 6. まとめフロー図
```
【ログインフェーズ】
[ユーザー（画面）] 
ID/PWでログイン実行
↓
[APIサーバー]
① 認証処理: DBでID/PWを照合（パスワードハッシュ検証）
② 認証成功 → JWTを発行
   - Payload作成: {"userId": 123, "exp": 1234567890}
   - 秘密鍵で署名
   - Header.Payload.Signature 形式に変換
↓
[ユーザー（画面）]
JWTを受け取り、Cookieなどに保存（XSS対策でHttpOnlyをつけるのが一般的）

【API呼び出しフェーズ】
[ユーザー（画面）] 
ログイン後の画面からなにかしらのAPI実行
この時にAuthorizationヘッダにJWTを設定
↓
[APIサーバー] 
① JWT検証: 受け取ったJWTの署名を秘密鍵で検証
   - HeaderとPayloadから新しくSignatureを再計算
   - 受け取った「Signature」と一致するか確認
   （ライブラリのメソッドで簡単に検証できる）
② 検証成功 → PayloadからuserIdを取り出す
③ userIdを使ってDBからデータ取得（またはビジネスロジック実行）
↓
[ユーザー（画面）] 
APIサーバーからAPIの処理結果が返却される

ポイント: 
- 「認証」はID/PWのDB照合（サーバーの責任）
- 「JWT」はその結果を表現するデータ形式
- JWT検証は「このトークンは改ざんされていないか」のチェック
```

---

## 4. ライブラリとかをインストールすることで実装を実現できるのか？
JWTの署名生成・検証を一から実装するのは大変なので、各言語には便利なライブラリがある。  

**重要: ライブラリはJWTの「発行」と「検証」を簡単にしてくれるツールであり、認証の仕組み全体ではない**

例:  
- Node.js: `jsonwebtoken`  
- Python: `PyJWT`  
- Java: `jjwt`  
- Go: `golang-jwt/jwt`

これらライブラリは「Header + Payload + 秘密鍵 → 署名生成」と「署名検証」をやってくれる。  
開発者は **秘密鍵を設定し、Payloadに入れるデータを決める** だけでOK。  

例（Node.js / jsonwebtoken）：
```javascript
const jwt = require('jsonwebtoken');
const secretKey = "秘密鍵の文字列"; // ←自分で用意・管理する（環境変数推奨）

// JWT発行（ログイン成功時）
const token = jwt.sign(
  { userId: 123, exp: Math.floor(Date.now() / 1000) + 3600 }, // Payload
  secretKey, 
  { algorithm: 'HS256' }
);

// JWT検証（API呼び出し時）
try {
  const decoded = jwt.verify(token, secretKey);
  console.log(decoded.userId); // 123
} catch(err) {
  console.log('トークンが無効です');
}
```

**ライブラリが提供するもの:**  
- JWT形式のトークン生成（sign）
- 署名検証（verify）
- Payloadのエンコード・デコード

**開発者が実装する必要があるもの:**  
- ユーザー認証のロジック（ID/PWのDB照合）
- ログインAPIのエンドポイント
- API呼び出し時の検証ミドルウェア
- エラーハンドリング（トークン期限切れ、不正なトークンなど）

---

## 5. JWTを使った認証で必ずやること
必ず押さえておくべき4つ：

1. **認証（Authentication）**  
   - ユーザーのID/PWをDB照合して本人確認する（JWT以前の話）
   
2. **JWT発行（sign）**  
   - 認証成功後、秘密鍵でJWTを作る（Payload に userId, exp などを含める）
   
3. **JWT検証（verify）**  
   - API呼び出し時にJWTの署名が正しいかを秘密鍵で確認する
   
4. **認可（Authorization）**  
   - Payloadから取り出した情報（userId など）で権限確認する

**JWTの役割はあくまで「2. 発行」と「3. 検証」の部分だけ。**  
認証や認可のロジックは別途実装が必要。

その他は要件次第（例: 保存場所、リフレッシュトークン、失効処理、有効期限管理）。  

---

## 6. 秘密鍵の管理（Key Vaultなど）
- **秘密鍵はJWTライブラリが勝手に作るものではない**  
  → 秘密鍵は開発者が自分で用意・管理する  
- 秘密鍵はソースコードにベタ書きせず、**環境変数やKMS（Key Management Service）で安全に管理**  
- KMS（Azure Key Vault、AWS Secrets Manager、Google Secret Manager など）を使えば：  
  - サーバー起動時に安全に鍵を取得できる  
  - アクセス権限を細かく制御可能  
  - ローテーションや監査ログもサポートされる  

**対称鍵（HS256）の場合:**  
- 署名と検証に同じ秘密鍵を使う
- 秘密鍵を持つ全てのサーバーが発行・検証できる
- 秘密鍵が漏れると全て危険

**非対称鍵（RS256）の場合:**  
- 秘密鍵（Private Key）で署名、公開鍵（Public Key）で検証
- 認可サーバーだけが秘密鍵を持ち、各APIサーバーは公開鍵で検証
- より安全（Oktaなどはこちらが標準）

---

## まとめ
JWTは、  
- **トークンのフォーマット（データ構造の仕様）であり、JWT自体は認証の仕組みではない**  
- **認証に使われる「データの入れ物」として、署名（秘密鍵を使った計算結果）で改ざん検知できる**  
- **JWTライブラリは「発行」と「検証」を簡単にするツール。認証・認可のロジックは別途実装が必要**  
- **秘密鍵は自分たちで用意し、安全に管理する（環境変数、KMSなど）**  
- **「JWTはフォーマット」という理解があれば、すでにあるAPIへの導入設計も迷わない**

**関連ページ:**  
- [認証・セキュリティ基礎](index.md) - OAuth、JWT、Oktaの全体像  
