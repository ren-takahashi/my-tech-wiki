# プログラミング概念

### アセンブリ言語
CPUが実行する命令に非常に近い低レベル言語。<br>
高い性能やハードウェア制御が必要な場面で使われるが、記述が難しく可搬性が低い。<br>
組み込み機器やパフォーマンスが極めて重要な一部の処理で用いられる。<br>

---

### インタプリタ言語
ソースコードを逐次読みながらその場で翻訳・実行するタイプの言語。<br>
書いたコードをすぐ実行できる利便性がある反面、実行速度はコンパイル済みの言語より遅くなることがある。<br>
PythonやJavaScriptは代表的なインタプリタ言語（実行環境によってはJITコンパイルなども使われる）。<br>

---

### Node.js（ノードジェイエス）
Node.jsはJavaScriptをサーバーサイドで動かす実行環境で、外部パッケージをnpmでインストールして機能を追加するのが一般的。<br>
多くの「API（機能）」がパッケージとして提供され、簡単に組み合わせて使える。<br>
`npm install express` でWebサーバー機能を使い、`npm install axios` でHTTP通信を簡単に行える。<br>

---

### IDE（Integrated Development Environment：統合開発環境）
コードエディタ、デバッガ、コンパイラ、ビルドツールなどを一つのソフトウェアに統合した開発ツール。<br>
単なるテキストエディタと違い、コード補完、リアルタイムエラー表示、デバッグ、バージョン管理などが統合されている。<br>

**IDEでできること:**<br>
- **コード補完（IntelliSense）**: 変数名や関数名を途中まで入力すると候補を表示<br>
- **リアルタイムエラー表示**: 構文エラーやタイプミスを書いた瞬間に検知<br>
- **デバッグ**: ブレークポイントを設定して変数の値を確認しながら実行<br>
- **リファクタリング支援**: 変数名変更、関数抽出などを安全に実行<br>
- **Git統合**: コミット、プッシュ、ブランチ切り替えがGUI操作でできる<br>
- **プラグイン・拡張機能**: 言語やフレームワークごとに機能を追加<br>

**代表的なIDE:**<br>
- **VS Code（Visual Studio Code）**: Microsoft製、軽量で拡張性が高い、最も人気<br>
- **IntelliJ IDEA**: JetBrains製、Java開発に特化（Kotlin、Scalaも）<br>
- **PyCharm**: JetBrains製、Python開発に特化<br>
- **Eclipse**: オープンソース、Java開発で歴史がある<br>
- **Visual Studio**: Microsoft製、C#/.NET開発に強い<br>
- **Android Studio**: Google製、Androidアプリ開発専用<br>
- **Xcode**: Apple製、iOS/macOSアプリ開発専用<br>

**テキストエディタとの違い:**<br>

| 項目 | テキストエディタ | IDE |
|------|----------------|-----|
| **主な用途** | テキスト編集全般 | プログラミング特化 |
| **コード補完** | 基本的になし（拡張で追加可能） | 標準搭載 |
| **デバッグ** | なし（別ツール必要） | 統合されている |
| **プロジェクト管理** | ファイル単位 | プロジェクト単位 |
| **起動速度** | 高速 | やや重い |
| **例** | メモ帳、Vim、Sublime Text | VS Code、IntelliJ、Eclipse |

ただし、**VS Codeはエディタとして生まれたが、拡張機能でIDE並みの機能を持つ**ため、境界線は曖昧になってきている。<br>

**実務での選び方:**<br>
- **言語を問わず幅広く使いたい** → VS Code<br>
- **Java/Kotlin開発** → IntelliJ IDEA<br>
- **Python開発（大規模）** → PyCharm<br>
- **C#/.NET開発** → Visual Studio<br>
- **軽量なエディタが好き** → Vim、Sublime Text（+ 拡張機能）<br>

チーム開発では「みんなが同じIDEを使う」ことで設定やプラグインを共有しやすくなる。<br>

---

### タスクランナー（Task Runner）
開発時に繰り返し実行する作業（ビルド、テスト、デプロイ、ファイル監視など）を自動化するツール。<br>
コマンド一つで複数の処理を順番に実行でき、開発効率が大幅に向上する。<br>

**タスクランナーでできること:**<br>
- **ビルド自動化**: TypeScriptのコンパイル、Sassのコンパイル、ファイル結合・圧縮<br>
- **テスト実行**: 単体テスト、E2Eテストの自動実行<br>
- **ファイル監視**: コード変更時に自動でビルド・リロード（ホットリロード）<br>
- **コード品質チェック**: ESLint、Prettierなどのリンター・フォーマッター実行<br>
- **デプロイ**: サーバーへのファイル転送、Docker イメージのビルド<br>
- **並列実行**: 複数のタスクを同時に実行して時間短縮<br>

**代表的なタスクランナー:**<br>
- **npm scripts（package.json）**: Node.jsプロジェクトで最も基本的、設定が軽量<br>
- **Webpack**: JavaScriptのモジュールバンドラー、React/Vueなどのビルドに必須<br>
- **Vite**: 次世代の高速ビルドツール、開発サーバー起動が爆速<br>
- **Gulp**: ストリーミングベースのタスクランナー、柔軟で強力<br>
- **Grunt**: 設定ベースのタスクランナー、歴史があるが最近は使用減少<br>
- **Make（Makefile）**: Linux/Unixの伝統的なビルドツール、C言語やサーバー管理で使用<br>
- **Task（Taskfile）**: Go言語で書かれたタスクランナー、シンプルで高速<br>

**具体例（npm scripts）:**<br>
```json
// package.json
{
  "scripts": {
    "build": "tsc && webpack --mode production",
    "test": "jest",
    "dev": "webpack serve --mode development",
    "lint": "eslint src/**/*.ts",
    "deploy": "npm run build && scp -r dist/ server:/var/www/"
  }
}
```

コマンド実行例：
```bash
npm run build   # TypeScriptコンパイル → Webpackビルド
npm run test    # テスト実行
npm run dev     # 開発サーバー起動（ファイル監視＋自動リロード）
npm run deploy  # ビルド → サーバーにデプロイ
```

**IDEとの違い:**<br>

| 項目 | タスクランナー | IDE |
|------|--------------|-----|
| **主な用途** | ビルド・デプロイの自動化 | コード編集・デバッグ |
| **起動方法** | コマンドライン | GUIアプリケーション |
| **設定ファイル** | package.json、Makefile など | .vscode/settings.json など |
| **CI/CDとの統合** | 容易（コマンド実行） | 難しい（GUI操作） |
| **チーム共有** | 設定ファイルをGit管理 | 個人の好みに依存しがち |

**実務での使い分け:**<br>
- **タスクランナー**: ビルド、テスト、デプロイなど「自動化したい作業」<br>
- **IDE**: コード編集、デバッグ、リファクタリングなど「手動で行う開発作業」<br>
- **併用が基本**: IDEでコード編集 → タスクランナーでビルド・デプロイ<br>

**メリット:**<br>
- 人為的ミスが減る（手動操作が不要）<br>
- 作業時間が短縮される（ワンコマンドで完了）<br>
- チーム全体で同じ手順を共有できる<br>
- CI/CDパイプラインに組み込みやすい<br>

---

### プロセス（Process）
**プログラムを実行している「1つの単位」。**<br>
実行中のアプリケーション1つ = 1つのプロセス。<br>

**イメージ: プロセス = レストラン全体**<br>
- ブラウザを開く = レストランを1軒オープンする<br>
- Excelを開く = 別のレストランをもう1軒オープンする<br>
- 各レストラン（プロセス）は独立していて、お互いに影響しない<br>

**プロセスの特徴:**<br>
- **独立したメモリ空間**: 他のプロセスのメモリを直接触れない（安全だが重い）<br>
- **OS管理**: OSがプロセスごとにCPU時間を割り当てて動かす<br>
- **1つのプロセスがクラッシュ**: 他のプロセスには影響しない（例: ブラウザが落ちてもExcelは平気）<br>

**実際に確認できる場所:**<br>
- **Windowsタスクマネージャー**: Ctrl+Shift+Esc で開く「プロセス」タブ<br>
- **Linuxコマンド**: `ps aux` や `top` コマンドで実行中のプロセス一覧を表示<br>
- **Macアクティビティモニタ**: アプリケーション → ユーティリティ → アクティビティモニタ<br>

**どんな時に意識するか:**<br>
- **アプリが重い時**: タスクマネージャーで「どのプロセスがCPUやメモリを食っているか」確認<br>
- **プログラムがフリーズ**: プロセスを強制終了（Task Kill）する<br>
- **サーバー運用**: Webサーバー（Apache、Nginx）が何個のプロセスで動いているか確認<br>
- **エラーメッセージ**: "Process killed" "Out of memory for process" など<br>

---

### スレッド（Thread）
**プロセスの中で実際に処理を行う「作業の流れ」の単位。**<br>
1つのプロセス（アプリ）の中に、複数のスレッド（作業員）がいる。<br>

**イメージ: スレッド = レストランのスタッフ**<br>
- 1つのレストラン（プロセス）の中に、複数のスタッフ（スレッド）がいる<br>
- スタッフAは料理、スタッフBは接客、スタッフCは皿洗い を同時にやる<br>
- 全員が同じキッチン（メモリ）を共有して働く<br>

**スレッドの特徴:**<br>
- **メモリを共有**: 同じプロセス内のスレッド同士はメモリを共有（速いが注意が必要）<br>
- **軽量**: プロセスより作成・切り替えのコストが低い<br>
- **並行処理**: 複数のスレッドが同時に動くことで効率アップ<br>

**1つのプロセスに最低1つのスレッドが必ず存在:**<br>
- プログラムを起動 → 1つのプロセス + 1つのメインスレッド が自動的に作られる<br>
- 追加でスレッドを作れば「マルチスレッド」になる<br>

---

### マルチスレッド（Multi-threading）
**1つのプロセスの中で、複数のスレッドを使って複数の処理を同時に進める仕組み。**<br>

**イメージ: スタッフを増やして効率アップ**<br>
```
シングルスレッド（1人のスタッフ）:
料理を作る → 接客する → 皿洗いする （順番に1つずつ）

マルチスレッド（3人のスタッフ）:
スタッフA: 料理を作る
スタッフB: 接客する        } 同時に進行！
スタッフC: 皿洗いする
```

**実務でよく見る例:**<br>

1. **Webブラウザ**<br>
   - メインスレッド: 画面表示・ユーザー操作<br>
   - ダウンロードスレッド: ファイルダウンロード<br>
   - レンダリングスレッド: ページの描画<br>
   → ダウンロード中も画面をスクロールできる！<br>

2. **Webサーバー**<br>
   - ユーザーAのリクエスト → スレッド1が処理<br>
   - ユーザーBのリクエスト → スレッド2が処理<br>
   - ユーザーCのリクエスト → スレッド3が処理<br>
   → 同時に複数のユーザーを処理できる！<br>

3. **動画編集アプリ**<br>
   - メインスレッド: UI表示<br>
   - エンコードスレッド: 動画変換（重い処理）<br>
   → 変換中も画面が固まらない！<br>

4. **ゲーム**<br>
   - 描画スレッド: 画面表示（60fps）<br>
   - 物理演算スレッド: キャラクターの動き計算<br>
   - サウンドスレッド: 音楽再生<br>
   → ヌルヌル動く！<br>

**どんな時に意識するか:**<br>

**1. プログラミング時:**<br>
- **重い処理を実行する時**: 「UIが固まらないように別スレッドで実行」を検討<br>
- **Node.jsは基本シングルスレッド**: 重い計算は Worker Threads を使う<br>
- **Pythonのマルチスレッド**: GIL（Global Interpreter Lock）の制約がある<br>
- **Javaはマルチスレッドが得意**: `Thread` クラスや `ExecutorService` を使う<br>

**2. エラーが出た時:**<br>
- "Thread deadlock detected"（デッドロック: スレッド同士が待ち合ってフリーズ）<br>
- "Race condition"（競合状態: 複数スレッドが同じデータを書き換えて矛盾）<br>
- "Thread pool exhausted"（スレッドプールが枯渇）<br>

**3. パフォーマンス改善時:**<br>
- 「この処理、もっと速くできない？」→ マルチスレッド化を検討<br>
- ただし何でもマルチスレッドにすればいいわけではない（後述）<br>

**メリット:**<br>
- **処理速度向上**: 重い処理を並行実行できる<br>
- **UIの応答性**: 処理中も画面が固まらない<br>
- **リソース効率**: 待ち時間（I/O待ちなど）を有効活用<br>

**デメリット・注意点:**<br>
- **実装が複雑**: バグが入りやすい（デッドロック、競合状態）<br>
- **デバッグが難しい**: 再現しにくいバグが出やすい<br>
- **メモリ共有の危険**: 同じデータを複数スレッドが触ると壊れる可能性<br>
- **オーバーヘッド**: スレッドが多すぎると逆に遅くなる<br>

**プロセス vs スレッド まとめ表:**<br>

| 項目 | プロセス | スレッド |
|------|---------|---------|
| **比喩** | レストラン全体 | レストランのスタッフ |
| **メモリ** | 各自独立（共有しない） | 同じプロセス内で共有 |
| **作成コスト** | 重い | 軽い |
| **切り替えコスト** | 高い | 低い |
| **安全性** | 高い（隔離されている） | 低い（共有メモリの衝突リスク） |
| **通信方法** | IPC（プロセス間通信）が必要 | 直接メモリアクセス可能 |
| **クラッシュ時** | 他プロセスに影響なし | 同じプロセス全体が落ちる |
| **用途** | 独立したアプリケーション | 同一アプリ内の並行処理 |

**初心者が最初に覚えるべきこと:**<br>
1. **プロセス = アプリ1つ、スレッド = その中の作業員**<br>
2. **重い処理は別スレッドで実行しないと画面が固まる**<br>
3. **マルチスレッドは速いけど難しい。慣れるまではライブラリに任せる**<br>
4. **タスクマネージャーでプロセスを見る習慣をつける**<br>

**プログラミング言語ごとの特徴:**<br>
- **JavaScript/Node.js**: 基本シングルスレッド、非同期処理（async/await）で補う<br>
- **PHP**: 基本的にシングルスレッド、マルチスレッドはあまり使われない<br>
- **Python**: GILの制約あり、CPU負荷の高い処理は multiprocessing を使う<br>
- **Java/C#**: マルチスレッド対応がしっかりしている<br>
- **Go言語**: goroutine という軽量スレッドで並行処理が得意<br>
- **Rust**: 安全性を保ちながらマルチスレッド可能<br>

---

### シンタックスシュガー（Syntactic Sugar）
プログラミング言語において、本質的な機能は変わらないが、より読みやすく書きやすくするための構文上の工夫のこと。<br>
「構文上の糖衣」という意味で、複雑な処理を甘く（簡単に）見せる表現方法。<br>

**特徴:**<br>
- 既存の機能を別の書き方で表現できるようにしたもの<br>
- コンパイル時や実行時には元の基本的な処理に変換される<br>
- コードの可読性や記述の簡潔性を向上させる<br>

**具体例（JavaScript）:**<br>
```javascript
// 従来の書き方 例1:
var name = person.name ? person.name : 'Guest';
// シンタックスシュガー（Null合体演算子）
var name = person.name ?? 'Guest';

// 従来の書き方 例2:
var double = function(x) {
    return x * 2;
};
// シンタックスシュガー（アロー関数）
var double = (x) => x * 2;
```

**メリット:** コードが短く簡潔になり、可読性が向上する。開発効率も上がる。<br>
**注意点:** 過度に使うと初心者には理解しにくくなる。内部的には同じ処理をしているため、パフォーマンスは基本的に変わらない。<br>

シンタックスシュガーは「砂糖で甘くする」ように、プログラミングを「甘く（簡単に）」してくれる便利な機能。<br>

---

### ビットフラグ（Bit Flag）
0と1の並びで複数の状態（ON/OFF）を1つの数値で管理する手法。<br>
各桁（ビット）が独立したフラグとして機能し、メモリ効率よく複数の設定を扱える。<br>

**具体例:**<br>
```
API取得項目の指定: 10101
→ 1桁目=ON（名前を取得）
→ 2桁目=OFF（住所は取得しない）
→ 3桁目=ON（電話番号を取得）
→ 4桁目=OFF（メールは取得しない）
→ 5桁目=ON（年齢を取得）
```

**使われる場面:**<br>
- APIのクエリパラメータ（取得項目の絞り込み）<br>
- ユーザー権限管理（読み取り、書き込み、削除などの権限）<br>
- 機能のON/OFF設定（複数機能を1つのパラメータで管理）<br>
- Linuxのファイル権限（rwx = 読み書き実行）<br>

**メリット:** 複数の設定を1つの数値で表現でき、メモリ効率が良い。パラメータ数を減らせる。<br>
**注意点:** 人間には読みにくく、ドキュメントがないと理解しづらい。桁数が増えると管理が複雑になる。<br>

レガシーシステムや性能重視のシステムでよく使われる、実務で見かける一般的な技術。<br>

---

### 浮動小数点数（Floating Point）／小数計算の誤差
コンピュータで小数を扱うときに使われる表現方法。<br>
ただし、**一部の小数（0.1、0.2など）は内部的に正確に表現できず、計算に誤差が出る**。<br>

**なぜ0.1が正確に表現できないのか？**<br>

コンピュータは2進数（0と1だけ）で数を扱います。<br>
10進数で簡単に書ける「0.1」は、2進数では無限に続く小数になってしまいます。<br>

**10進数と2進数の違い（例え）:**<br>
- **10進数での1/3**: 0.3333333...（無限に続く）<br>
- **2進数での0.1**: 0.0001100110011...（無限に続く）<br>

10進数で「1÷3」を計算すると無限小数になるのと同じように、<br>
2進数で「0.1」を表現しようとすると無限小数になります。<br>

**実際の誤差の例（JavaScript）:**<br>
```javascript
console.log(0.1 + 0.2);  // 0.30000000000000004 と表示される
console.log(0.1 + 0.2 === 0.3);  // false になる
```

**現場で注意が必要なケース:**<br>
- **金額計算**: ¥100 × 0.1（消費税10%）などの計算<br>
- **パーセント計算**: 割合や比率の計算<br>
- **科学技術計算**: 精密な数値計算が必要な場面<br>
- **等価比較**: 小数同士を `==` や `===` で比較する<br>

**誤差を検知するタイミング:**<br>
1. **変数の型を見る**: `float`, `double`, `Number`など小数型を使っている<br>
2. **計算内容を見る**: 割り算、掛け算で小数が出る可能性がある<br>
3. **要件を見る**: 「金額」「通貨」「消費税」などのワードがある<br>

**対処法:**<br>
- **整数で計算する**: 金額は「円」ではなく「銭」で計算（100円 = 10000銭）<br>
- **専用ライブラリを使う**: Decimal型、BigDecimal（Java）、decimal（Python）<br>
- **等価比較を避ける**: 差分が十分小さいかチェック（`Math.abs(a - b) < 0.0001`）<br>
- **四捨五入**: 必要な桁数で丸める（表示時や最終計算時）<br>

**現場での実例:**<br>
```
❌ 悪い例:
price = 100;
tax = price * 0.1;  // 10.000000000000001 になる可能性

✅ 良い例:
price = 100;
tax = Math.round(price * 10) / 100;  // 正確に 10 になる

または

price_in_cents = 10000;  // 100円を銭単位で
tax_in_cents = price_in_cents * 10 / 100;  // 整数計算
```

**覚えておくべきポイント:**<br>
- 小数計算は「見た目」と「内部の値」が違うことがある<br>
- お金の計算では必ず対策が必要<br>
- 単純な `==` 比較は危険<br>

この問題は**すべてのプログラミング言語に共通**しているコンピュータの根本的な制約。<br>

---

### メモリリーク（Memory Leak）
プログラムが確保したメモリを解放し忘れることで、メモリ使用量が増え続けてしまう問題。<br>
最終的にはシステムのメモリが枯渇し、アプリケーションがクラッシュしたり、システム全体が遅くなったりする。<br>

**発生する仕組み:**<br>
```
1. プログラムがメモリを確保（malloc, new など）
2. 使い終わったメモリを解放し忘れ（free, delete を呼ばない）
3. 確保されたまま放置されたメモリが積み重なる
4. 使えるメモリが減り続ける → システムが不安定に
```

**具体例:**<br>
- ループ内で毎回メモリを確保するが、解放処理を忘れている<br>
- イベントリスナーやコールバック関数を登録したまま削除しない<br>
- データベース接続やファイルハンドルを閉じずに放置<br>

**症状:**<br>
- 長時間稼働するとメモリ使用量が増え続ける<br>
- システムが徐々に遅くなる<br>
- 最終的にOut of Memoryエラーが発生<br>

**防ぐ方法:**<br>
- ガベージコレクション（GC）のある言語を使う（Java、Python、JavaScriptなど）<br>
- スマートポインタやRAII（C++）などの自動管理を活用<br>
- リソース管理を明示的に行う（try-finally、using文など）<br>
- メモリプロファイラーツールで定期的に監視<br>

**関連用語との関係:**<br>
- **ガベージコレクション（GC）**: 不要になったメモリを自動的に解放する仕組み。メモリリークを防ぐ。<br>
- **リソースリーク**: メモリ以外（ファイル、DB接続、ソケットなど）のリソース解放忘れ。<br>

現代の言語ではGCがあるためメモリリーク自体は起きにくいが、循環参照やイベントリスナーの削除忘れなどで発生することもある。<br>

---

### ガベージコレクション（Garbage Collection／GC／ジーシー）
プログラムが使わなくなったメモリを自動的に検出して解放する仕組み。<br>
開発者が手動でメモリ解放を管理する必要がなくなり、メモリリークのリスクが大幅に減る。<br>

**GCがある言語:**<br>
- PHP、Java、Python、JavaScript、C#、Go、Rubyなど<br>

**GCがない言語:**<br>
- C、C++（手動でmalloc/freeやnew/deleteを管理）<br>

**メリット:**<br>
- メモリリークが起きにくい<br>
- 開発が簡単（メモリ管理を意識しなくてよい）<br>

**デメリット:**<br>
- GC実行時にプログラムが一時停止することがある（STW: Stop The World）<br>
- メモリ使用量がやや多くなる傾向<br>

**GCがあっても発生するメモリリーク:**<br>
- 循環参照（オブジェクト同士が互いに参照し合っている）<br>
- グローバル変数やキャッシュに溜め込んだまま放置<br>
- イベントリスナーやコールバックの削除忘れ<br>

GCは便利だが万能ではなく、適切なリソース管理は依然として重要。<br>

---

### リソースリーク（Resource Leak）
メモリ以外のリソース（ファイル、データベース接続、ソケット、スレッドなど）を解放し忘れる問題。<br>
メモリリークと同様、リソースが枯渇してシステムが不安定になる。<br>

**よくある例:**<br>
- ファイルを開いたまま閉じない（ファイルハンドルリーク）<br>
- データベース接続を切断せずに放置（コネクションリーク）<br>
- ネットワークソケットを閉じない（ソケットリーク）<br>
- スレッドを終了させずに放置（スレッドリーク）<br>

**症状:**<br>
- 「Too many open files」エラー<br>
- データベース接続プールが枯渇<br>
- システムリソースが足りなくなる<br>

**防ぐ方法:**<br>
- try-finallyやusing文でリソースを確実に解放<br>
- Pythonのwith文、Javaのtry-with-resources<br>
- 接続プールやリソースプーリングの活用<br>

ガベージコレクションはメモリを自動管理するが、**ファイルやDB接続などは自動で閉じてくれない**ため、明示的な解放が必要。<br>
