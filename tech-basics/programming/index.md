# プログラミング概念

### アセンブリ言語
CPUが実行する命令に非常に近い低レベル言語。<br>
高い性能やハードウェア制御が必要な場面で使われるが、記述が難しく可搬性が低い。<br>
組み込み機器やパフォーマンスが極めて重要な一部の処理で用いられる。<br>

---

### インタプリタ言語
ソースコードを逐次読みながらその場で翻訳・実行するタイプの言語。<br>
書いたコードをすぐ実行できる利便性がある反面、実行速度はコンパイル済みの言語より遅くなることがある。<br>
PythonやJavaScriptは代表的なインタプリタ言語（実行環境によってはJITコンパイルなども使われる）。<br>

---

### Node.js（ノードジェイエス）
Node.jsはJavaScriptをサーバーサイドで動かす実行環境で、外部パッケージをnpmでインストールして機能を追加するのが一般的。<br>
多くの「API（機能）」がパッケージとして提供され、簡単に組み合わせて使える。<br>
`npm install express` でWebサーバー機能を使い、`npm install axios` でHTTP通信を簡単に行える。<br>

---

### IDE（Integrated Development Environment：統合開発環境）
コードエディタ、デバッガ、コンパイラ、ビルドツールなどを一つのソフトウェアに統合した開発ツール。<br>
単なるテキストエディタと違い、コード補完、リアルタイムエラー表示、デバッグ、バージョン管理などが統合されている。<br>

**IDEでできること:**<br>
- **コード補完（IntelliSense）**: 変数名や関数名を途中まで入力すると候補を表示<br>
- **リアルタイムエラー表示**: 構文エラーやタイプミスを書いた瞬間に検知<br>
- **デバッグ**: ブレークポイントを設定して変数の値を確認しながら実行<br>
- **リファクタリング支援**: 変数名変更、関数抽出などを安全に実行<br>
- **Git統合**: コミット、プッシュ、ブランチ切り替えがGUI操作でできる<br>
- **プラグイン・拡張機能**: 言語やフレームワークごとに機能を追加<br>

**代表的なIDE:**<br>
- **VS Code（Visual Studio Code）**: Microsoft製、軽量で拡張性が高い、最も人気<br>
- **IntelliJ IDEA**: JetBrains製、Java開発に特化（Kotlin、Scalaも）<br>
- **PyCharm**: JetBrains製、Python開発に特化<br>
- **Eclipse**: オープンソース、Java開発で歴史がある<br>
- **Visual Studio**: Microsoft製、C#/.NET開発に強い<br>
- **Android Studio**: Google製、Androidアプリ開発専用<br>
- **Xcode**: Apple製、iOS/macOSアプリ開発専用<br>

**テキストエディタとの違い:**<br>

| 項目 | テキストエディタ | IDE |
|------|----------------|-----|
| **主な用途** | テキスト編集全般 | プログラミング特化 |
| **コード補完** | 基本的になし（拡張で追加可能） | 標準搭載 |
| **デバッグ** | なし（別ツール必要） | 統合されている |
| **プロジェクト管理** | ファイル単位 | プロジェクト単位 |
| **起動速度** | 高速 | やや重い |
| **例** | メモ帳、Vim、Sublime Text | VS Code、IntelliJ、Eclipse |

ただし、**VS Codeはエディタとして生まれたが、拡張機能でIDE並みの機能を持つ**ため、境界線は曖昧になってきている。<br>

**実務での選び方:**<br>
- **言語を問わず幅広く使いたい** → VS Code<br>
- **Java/Kotlin開発** → IntelliJ IDEA<br>
- **Python開発（大規模）** → PyCharm<br>
- **C#/.NET開発** → Visual Studio<br>
- **軽量なエディタが好き** → Vim、Sublime Text（+ 拡張機能）<br>

チーム開発では「みんなが同じIDEを使う」ことで設定やプラグインを共有しやすくなる。<br>

---

### シンタックスシュガー（Syntactic Sugar）
プログラミング言語において、本質的な機能は変わらないが、より読みやすく書きやすくするための構文上の工夫のこと。<br>
「構文上の糖衣」という意味で、複雑な処理を甘く（簡単に）見せる表現方法。<br>

**特徴:**<br>
- 既存の機能を別の書き方で表現できるようにしたもの<br>
- コンパイル時や実行時には元の基本的な処理に変換される<br>
- コードの可読性や記述の簡潔性を向上させる<br>

**具体例（JavaScript）:**<br>
```javascript
// 従来の書き方 例1:
var name = person.name ? person.name : 'Guest';
// シンタックスシュガー（Null合体演算子）
var name = person.name ?? 'Guest';

// 従来の書き方 例2:
var double = function(x) {
    return x * 2;
};
// シンタックスシュガー（アロー関数）
var double = (x) => x * 2;
```

**メリット:** コードが短く簡潔になり、可読性が向上する。開発効率も上がる。<br>
**注意点:** 過度に使うと初心者には理解しにくくなる。内部的には同じ処理をしているため、パフォーマンスは基本的に変わらない。<br>

シンタックスシュガーは「砂糖で甘くする」ように、プログラミングを「甘く（簡単に）」してくれる便利な機能。<br>

---

### ビットフラグ（Bit Flag）
0と1の並びで複数の状態（ON/OFF）を1つの数値で管理する手法。<br>
各桁（ビット）が独立したフラグとして機能し、メモリ効率よく複数の設定を扱える。<br>

**具体例:**<br>
```
API取得項目の指定: 10101
→ 1桁目=ON（名前を取得）
→ 2桁目=OFF（住所は取得しない）
→ 3桁目=ON（電話番号を取得）
→ 4桁目=OFF（メールは取得しない）
→ 5桁目=ON（年齢を取得）
```

**使われる場面:**<br>
- APIのクエリパラメータ（取得項目の絞り込み）<br>
- ユーザー権限管理（読み取り、書き込み、削除などの権限）<br>
- 機能のON/OFF設定（複数機能を1つのパラメータで管理）<br>
- Linuxのファイル権限（rwx = 読み書き実行）<br>

**メリット:** 複数の設定を1つの数値で表現でき、メモリ効率が良い。パラメータ数を減らせる。<br>
**注意点:** 人間には読みにくく、ドキュメントがないと理解しづらい。桁数が増えると管理が複雑になる。<br>

レガシーシステムや性能重視のシステムでよく使われる、実務で見かける一般的な技術。<br>

---

### 浮動小数点数（Floating Point）／小数計算の誤差
コンピュータで小数を扱うときに使われる表現方法。<br>
ただし、**一部の小数（0.1、0.2など）は内部的に正確に表現できず、計算に誤差が出る**。<br>

**なぜ0.1が正確に表現できないのか？**<br>

コンピュータは2進数（0と1だけ）で数を扱います。<br>
10進数で簡単に書ける「0.1」は、2進数では無限に続く小数になってしまいます。<br>

**10進数と2進数の違い（例え）:**<br>
- **10進数での1/3**: 0.3333333...（無限に続く）<br>
- **2進数での0.1**: 0.0001100110011...（無限に続く）<br>

10進数で「1÷3」を計算すると無限小数になるのと同じように、<br>
2進数で「0.1」を表現しようとすると無限小数になります。<br>

**実際の誤差の例（JavaScript）:**<br>
```javascript
console.log(0.1 + 0.2);  // 0.30000000000000004 と表示される
console.log(0.1 + 0.2 === 0.3);  // false になる
```

**現場で注意が必要なケース:**<br>
- **金額計算**: ¥100 × 0.1（消費税10%）などの計算<br>
- **パーセント計算**: 割合や比率の計算<br>
- **科学技術計算**: 精密な数値計算が必要な場面<br>
- **等価比較**: 小数同士を `==` や `===` で比較する<br>

**誤差を検知するタイミング:**<br>
1. **変数の型を見る**: `float`, `double`, `Number`など小数型を使っている<br>
2. **計算内容を見る**: 割り算、掛け算で小数が出る可能性がある<br>
3. **要件を見る**: 「金額」「通貨」「消費税」などのワードがある<br>

**対処法:**<br>
- **整数で計算する**: 金額は「円」ではなく「銭」で計算（100円 = 10000銭）<br>
- **専用ライブラリを使う**: Decimal型、BigDecimal（Java）、decimal（Python）<br>
- **等価比較を避ける**: 差分が十分小さいかチェック（`Math.abs(a - b) < 0.0001`）<br>
- **四捨五入**: 必要な桁数で丸める（表示時や最終計算時）<br>

**現場での実例:**<br>
```
❌ 悪い例:
price = 100;
tax = price * 0.1;  // 10.000000000000001 になる可能性

✅ 良い例:
price = 100;
tax = Math.round(price * 10) / 100;  // 正確に 10 になる

または

price_in_cents = 10000;  // 100円を銭単位で
tax_in_cents = price_in_cents * 10 / 100;  // 整数計算
```

**覚えておくべきポイント:**<br>
- 小数計算は「見た目」と「内部の値」が違うことがある<br>
- お金の計算では必ず対策が必要<br>
- 単純な `==` 比較は危険<br>

この問題は**すべてのプログラミング言語に共通**しているコンピュータの根本的な制約。<br>

---

### メモリリーク（Memory Leak）
プログラムが確保したメモリを解放し忘れることで、メモリ使用量が増え続けてしまう問題。<br>
最終的にはシステムのメモリが枯渇し、アプリケーションがクラッシュしたり、システム全体が遅くなったりする。<br>

**発生する仕組み:**<br>
```
1. プログラムがメモリを確保（malloc, new など）
2. 使い終わったメモリを解放し忘れ（free, delete を呼ばない）
3. 確保されたまま放置されたメモリが積み重なる
4. 使えるメモリが減り続ける → システムが不安定に
```

**具体例:**<br>
- ループ内で毎回メモリを確保するが、解放処理を忘れている<br>
- イベントリスナーやコールバック関数を登録したまま削除しない<br>
- データベース接続やファイルハンドルを閉じずに放置<br>

**症状:**<br>
- 長時間稼働するとメモリ使用量が増え続ける<br>
- システムが徐々に遅くなる<br>
- 最終的にOut of Memoryエラーが発生<br>

**防ぐ方法:**<br>
- ガベージコレクション（GC）のある言語を使う（Java、Python、JavaScriptなど）<br>
- スマートポインタやRAII（C++）などの自動管理を活用<br>
- リソース管理を明示的に行う（try-finally、using文など）<br>
- メモリプロファイラーツールで定期的に監視<br>

**関連用語との関係:**<br>
- **ガベージコレクション（GC）**: 不要になったメモリを自動的に解放する仕組み。メモリリークを防ぐ。<br>
- **リソースリーク**: メモリ以外（ファイル、DB接続、ソケットなど）のリソース解放忘れ。<br>

現代の言語ではGCがあるためメモリリーク自体は起きにくいが、循環参照やイベントリスナーの削除忘れなどで発生することもある。<br>

---

### ガベージコレクション（Garbage Collection／GC／ジーシー）
プログラムが使わなくなったメモリを自動的に検出して解放する仕組み。<br>
開発者が手動でメモリ解放を管理する必要がなくなり、メモリリークのリスクが大幅に減る。<br>

**GCがある言語:**<br>
- Java、Python、JavaScript、C#、Go、Rubyなど<br>

**GCがない言語:**<br>
- C、C++（手動でmalloc/freeやnew/deleteを管理）<br>

**メリット:**<br>
- メモリリークが起きにくい<br>
- 開発が簡単（メモリ管理を意識しなくてよい）<br>

**デメリット:**<br>
- GC実行時にプログラムが一時停止することがある（STW: Stop The World）<br>
- メモリ使用量がやや多くなる傾向<br>

**GCがあっても発生するメモリリーク:**<br>
- 循環参照（オブジェクト同士が互いに参照し合っている）<br>
- グローバル変数やキャッシュに溜め込んだまま放置<br>
- イベントリスナーやコールバックの削除忘れ<br>

GCは便利だが万能ではなく、適切なリソース管理は依然として重要。<br>

---

### リソースリーク（Resource Leak）
メモリ以外のリソース（ファイル、データベース接続、ソケット、スレッドなど）を解放し忘れる問題。<br>
メモリリークと同様、リソースが枯渇してシステムが不安定になる。<br>

**よくある例:**<br>
- ファイルを開いたまま閉じない（ファイルハンドルリーク）<br>
- データベース接続を切断せずに放置（コネクションリーク）<br>
- ネットワークソケットを閉じない（ソケットリーク）<br>
- スレッドを終了させずに放置（スレッドリーク）<br>

**症状:**<br>
- 「Too many open files」エラー<br>
- データベース接続プールが枯渇<br>
- システムリソースが足りなくなる<br>

**防ぐ方法:**<br>
- try-finallyやusing文でリソースを確実に解放<br>
- Pythonのwith文、Javaのtry-with-resources<br>
- 接続プールやリソースプーリングの活用<br>

ガベージコレクションはメモリを自動管理するが、**ファイルやDB接続などは自動で閉じてくれない**ため、明示的な解放が必要。<br>
