# Tech Basics Index (見出し形式)

<div style="height:50px;"></div>

# ネットワーク・インフラ基盤

### TCP（Transmission Control Protocol／ティーシーピー）
インターネット通信の基本プロトコル。<br>
データを相手に確実に届けるための仕組み（信頼性重視）。<br>
メールやWebページの表示でデータの欠落が起きないのはTCPのおかげ。<br>

---

### SSH（Secure Shell／エスエスエイチ）
サーバーに安全にリモート接続するための暗号化技術とプロトコル。<br>
通信内容や認証情報が暗号化されるため、盗聴やなりすましのリスクが低くなる。<br>
自宅から会社サーバーにログインしてファイル操作やコマンド実行を行うときに使う。<br>

---

### LAN（Local Area Network）
ランと呼ぶ。限られた範囲（家庭やオフィス）内で接続されたコンピュータやデバイスのネットワークのこと。<br>高速な通信が可能で、リソースの共有（プリンタやファイルなど）が容易。<br>
家庭LANや社内LANなど表現することが多い。<br>
社内LANはインターネットから隔離されていることが多く、セキュリティが高い。<br>

---

### IPアドレス（アイピーアドレス）
パソコンやルータに設定される住所の様な物。<br>
**パブリック（グローバル）IP**と**プライベートIP**の2種類がある。<br>

**パブリック（グローバル）IP:** インターネット上で使える世界で唯一のIPアドレス。<br>
例: `8.8.8.8`（Google DNS）、`203.0.113.1`など<br>

**プライベートIP:** 内部ネットワークでのみ使用。自由に設定可能で重複OK。<br>
範囲: `192.168.x.x`、`10.x.x.x`、`172.16.x.x〜172.31.x.x`<br>
例: `192.168.1.100`（家庭内ルーター）、`10.0.0.5`（企業内サーバー）<br>

**見分け方:** 上記プライベートIP範囲以外はすべてパブリックIP。<br>

---

### NAT（Network Address Translation／ナット）
Network Address Translation の略。<br>
内部ネットワークのプライベートIPを外部のグローバルIPに変換してやり取りする仕組みの総称。<br>
社内LANの複数端末が1つのグローバルIPで外部と通信する場面で使われる。<br>

---

### PAT（Port Address Translation／パット）
Port Address Translation の略。NATの一種。<br>
複数の内部端末が1つのグローバルIPを共有する際に、端末ごとに異なるポート番号を割り当てて通信を区別する仕組み。<br>
家庭用ルーターでよく使われる。<br>
同じルーターから複数端末が同時にWeb接続しても、戻りの通信を正しい端末に振り分けられる。<br>

---

### Internet Gateway（インターネットゲートウェイ）
内部ネットワーク（LAN）とインターネットをつなぐ「出入り口」の役割を果たす装置やサービス。<br>
オフィスビルの「正面玄関」のようなもので、内部と外部の通信を仲介する。<br>

**別の呼び方:** ルーター、ゲートウェイ、デフォルトゲートウェイ<br>

**何がInternet Gatewayにあたるか:**<br>
- **家庭**: Wi-Fiルーター（バッファロー、NECなど）<br>
- **企業**: 企業用ルーター、ファイアウォール<br>
- **クラウド**: AWS Internet Gateway、Azure vNet Gateway<br>

**主な機能:**<br>
- IPアドレス変換（プライベート ↔ パブリック）<br>
- 通信の振り分けとルーティング<br>
- セキュリティ制御（不正アクセスの防止）<br>

家でスマホがインターネットにつながるのも、会社のPCが外部サイトを見れるのも、すべてInternet Gatewayがあるから。<br>

---

### ファイアウォール（Firewall）
ネットワーク通信を監視・制御してセキュリティを保つ仕組み。<br>
建物の「防火壁」が語源で、悪意ある通信をブロックして内部を守る。<br>

**ファイアウォールの定義:**<br>
以下の機能を持つものを「ファイアウォール」と呼ぶ：<br>
- 通信の許可・拒否を制御<br>
- 送信元・送信先・ポート番号での判断<br>
- ログ記録機能<br>

**商品・サービス例（各社が製造）:**<br>
- **家庭**: Wi-Fiルーター内蔵機能（バッファロー、ASUS、TP-Link）<br>
- **企業**: FortiGate（Fortinet）、SonicWall、Palo Alto（Palo Alto Networks）<br>
- **ソフトウェア**: Windows Defender ファイアウォール、iptables（Linux）<br>
- **クラウド**: AWS Security Groups、Azure Network Security Groups<br>

**種類:**<br>
- **ハードウェア型**: 専用機器（企業向け）<br>
- **ソフトウェア型**: PC・サーバーにインストール<br>
- **統合型**: ルーターに内蔵（家庭・小規模オフィス）<br>

「冷蔵庫」や「エアコン」と同じように、各社が独自製品を作っている技術分野。<br>
ちなみに家庭用ルーターのファイアウォール機能も製品によっては意外とできることが多い。<br>
例えば、子供のスマホやゲーム機を特定時間だけインターネット禁止にしたり、YouTubeなど特定サイトをブロックしたりできる。<br>

---

### FTP（File Transfer Protocol／エフティーピー）
昔からあるファイル転送プロトコル。<br>
サーバーとクライアント間でファイルをやり取りできるが、通信が暗号化されないためパスワードやデータが盗聴されやすい。<br>
現在は安全な代替手段が推奨される。<br>

**仕組み:**<br>
- **送信側**: FTPクライアント（FileZillaなど）でファイルを送信<br>
- **受信側**: OSにFTPサーバーソフト（vsftpd、ProFTPDなど）をインストールして受信環境を構築<br>

**設定に必要なもの:**<br>
- FTPサーバーソフトのインストール・設定<br>
- 送信側が接続するためのユーザーアカウント作成<br>
- ファイアウォール設定（ポート21の開放）<br>

古いWebホスティングでファイルをアップロードする際に使われていたが、セキュリティ上の問題で利用は減っている。<br>

---

### SFTP（SSH File Transfer Protocol／エスエフティーピー）
SSHを使ってファイルを暗号化して安全に転送するプロトコル。<br>
FTPの安全版と考えればよい。<br>
パスワードやファイル内容が暗号化されるため、現代ではこちらが推奨される。<br>
安全にサーバーへファイルをアップロードする際に使う。<br>

---

### DMZ（DeMilitarized Zone／ディーエムゼット／非武装地帯）
内部ネットワーク（社内LAN）と外部ネットワーク（インターネット）の間に設置される**中間的なネットワーク領域**。<br>
外部に公開する必要があるサーバー（Webサーバー、メールサーバーなど）を配置し、内部ネットワークを守る。<br>

**なぜDMZが必要か:**<br>
- 外部公開サーバーを社内LANに直接置くと、攻撃された際に社内全体が危険にさらされる<br>
- DMZに置けば、攻撃されても被害を限定できる（社内LANへの侵入を防ぐ）<br>

**DMZの構成イメージ:**<br>
```
インターネット
    ↓
ファイアウォール①
    ↓
  【DMZ】 ← 外部公開サーバー（Webサーバー、メールサーバー）
    ↓
ファイアウォール②
    ↓
社内LAN ← 重要な業務サーバー、PC（外部から直接アクセス不可）
```

**DMZに置かれるサーバー:**<br>
- Webサーバー（公開サイト）<br>
- メールサーバー（外部とメール送受信）<br>
- DNSサーバー（外部向け）<br>
- VPNゲートウェイ<br>

**DMZに置かない（社内LANに置く）サーバー:**<br>
- データベースサーバー（顧客情報など重要データ）<br>
- ファイルサーバー（社内文書）<br>
- 業務システムサーバー<br>

**セキュリティの考え方:**<br>
- DMZのサーバーは「攻撃される可能性がある」前提で運用<br>
- DMZから社内LANへの通信は厳しく制限<br>
- 二重のファイアウォールで多層防御（Defense in Depth）<br>

**現場での呼び方:**<br>
「WebサーバーはDMZに配置します」= 外部公開用の中間ネットワークに設置<br>
「DBサーバーは内部に置きます」= 社内LAN（DMZの内側）に設置<br>

軍事用語の「非武装地帯」から名付けられた、企業ネットワークの標準的なセキュリティ設計。<br>

<div style="height:50px;"></div>

# アーキテクチャ・設計

### スケールアウト（Scale-out） / スケールイン（Scale-in）
サーバーの台数を増やして処理を分散するのがスケールアウト。<br>逆に台数を減らしてコストを下げるのがスケールイン。<br>

メリット： 同時接続数や並列処理能力を簡単に伸ばせる。可用性（冗長化）も向上する。<br>
注意点： セッション管理やデータ整合性、設定の同期が必要になることが多い。

---

### スケールアップ（Scale-up） / スケールダウン（Scale-down）
既存のサーバー自体のCPUやメモリ、ディスク容量を増やして性能を上げるのがスケールアップ。<br>逆にリソースを下げるのがスケールダウン。<br>

メリット： 単純に処理性能を上げやすく、アプリ側の設計変更が少ない場合がある。<br>
注意点： 物理的・インスタンスの上限があり、スケールアウトほど柔軟でない。ダウンタイムが発生する可能性がある。

---

### フェイルオーバー（Failover）
システム障害が発生した際に、自動的に予備系（待機系）のサーバーやシステムに切り替えて、サービスを継続する仕組み。<br>
「障害時の自動切り替え」と理解すればよい。<br>

**主な目的:** 可用性の向上（システムを止めないこと）。障害発生時のダウンタイムを最小化する。<br>

**フェイルオーバーの構成例:**<br>
```
アクティブ・スタンバイ構成（ホットスタンバイ）:
┌─────────┐
│サーバーA│  
│(稼働中) │   障害発生！
└─────────┘ 
 ↓ 切り替え         
┌─────────┐
│サーバーB│
│(待機中) │ → 稼働開始
└─────────┘


アクティブ・アクティブ構成:
┌─────────┐
│サーバーA│ ← 両方とも稼働中
│(稼働中) │    負荷分散
└─────────┘
┌─────────┐
│サーバーB│ ← Aが落ちても
│(稼働中) │    Bが全て処理
└─────────┘
```

**スケールアウトとの違い:**<br>

| 項目 | スケールアウト | フェイルオーバー |
|------|---------------|------------------|
| **主な目的** | 性能向上・負荷分散 | 可用性向上・障害対策 |
| **サーバーの役割** | 全台が常に稼働して負荷分散 | 予備系は待機（または軽負荷） |
| **障害時の動作** | 残りのサーバーで処理継続 | 予備系へ自動切り替え |
| **導入理由** | 「遅い」を解決 | 「止まらない」を実現 |

**重要な違い:**<br>
- **スケールアウト**: 複数サーバーが同時に処理して性能を上げる。結果的に1台落ちても大丈夫だが、本来の目的は「速くすること」。<br>
- **フェイルオーバー**: 障害時に切り替えることが目的。性能向上は副次的効果。<br>

**実際の関係性:**<br>
スケールアウト構成（複数サーバー）を組むと、自然とフェイルオーバー能力も得られることが多い。<br>
しかし、フェイルオーバーのために必ずしもスケールアウトが必要なわけではない（アクティブ・スタンバイ構成は2台だけ）。<br>

**使われる場面:**<br>
- データベースサーバー（マスター・スレーブ構成）<br>
- Webサーバー（ロードバランサー配下で自動切り替え）<br>
- ネットワーク機器（ルーター、ファイアウォールの冗長化）<br>
- クラウドサービス（AWSのMulti-AZ、Azureの可用性セット）<br>

**フェイルバック:**<br>
障害が復旧した後、元の主系（サーバーA）に戻す作業をフェイルバックという。<br>
自動で戻す場合もあれば、手動で戻す場合もある。<br>

---

### クラスタ構成（クラスター）／クラスタリング
複数のサーバーやノードを**1つのまとまり（クラスター）として連携させる構成**。<br>
アクティブ・アクティブでもアクティブ・スタンバイでも、外からは「1つのサービス」として見える設計。<br>
**性能向上・可用性・運用性など、複合的な目的**で導入されることが多い。<br>

**よくある目的:**<br>
- **可用性**（止まらない）を上げる<br>
- **性能**（さばける量）を上げる<br>
- **運用性**（メンテしやすい）を上げる<br>

**代表的なクラスタの形:**<br>
- **アクティブ・アクティブ**: 全台稼働で負荷分散（性能向上に強い）<br>
- **アクティブ・スタンバイ**: 片方稼働・片方待機（可用性重視）<br>

**スケールアウトとの関係:**<br>
- クラスタ構成は**複数台で動かす「仕組み」**<br>
- スケールアウトは**台数を増やす「手段」**<br>
→ つまり、スケールアウトはクラスタリングの一部として行われることが多い。<br>

**フェイルオーバーとの関係:**<br>
- クラスタ構成の中に**フェイルオーバー機能**が含まれることが多い（自動切り替え）。<br>

**冗長化との違い:**<br>
- **冗長化**: 基本的に**可用性（止まらない）目的が中心**。性能向上は主目的ではない。<br>
- **クラスタ構成**: 可用性だけでなく、**性能向上や負荷分散も含む**設計。<br>

**「クラスタ○○」の読み方:**<br>
クラスタDB、クラスタストレージなど「クラスタ○○」と呼ばれる場合、<br>
**複数台で構成された○○（HA・性能・負荷分散など複合的な目的）** という意味。<br>
単純な冗長化だけでなく、性能面の向上も含む場合が多い。<br>

**使われる場面:**<br>
- Webサーバーの冗長化（ロードバランサー配下）<br>
- データベースの冗長化（クラスタDB）<br>
- 共有ストレージの冗長化<br>

**注意点:**<br>
- セッション共有やデータ同期など、**複数台で整合性を保つ設計**が必要。<br>
- 構成が複雑になる分、運用コストは上がりやすい。<br>

「複数台で1つのシステムを作る考え方」そのものがクラスタ構成。<br>

---

### DevOps（デブオプス）
Development（開発）とOperations（運用）を組み合わせた造語。<br>
開発チームと運用チームの協力を促進する管理体制・文化・手法の総称。<br>
特定のサービスやツールではなく、組織運営の考え方や哲学を指す。<br>

**従来の問題:** 開発と運用が分離されていて、コミュニケーション不足や対立が発生。<br>
**DevOpsの解決策:** チーム間の壁を取り払い、共通目標に向けて協力する文化を醸成。<br>

**実践例:** CI/CD（自動テスト・自動デプロイ）、監視・フィードバック、アジャイル開発<br>
**関連ツール:** Azure DevOps、Jenkins、Docker、Kubernetesなど（ツール自体がDevOpsではない）<br>

---

### UAT環境（User Acceptance Test／ユーエーティー環境）
**別名:** 受け入れ環境、ユーザー受入テスト環境、承認環境<br>

User Acceptance Testの略。<br>
本番リリース前にユーザー（または発注者・利用部門）が最終確認を行うための検証環境。<br>
開発したシステムが要件を満たしているか、実際の業務で使えるかを確認する最終ステップ。

**環境の流れ（あくまで一般的な例）:**<br>
```
開発環境 → STG環境 → UAT環境 → 本番環境
(Dev)      (STG)    (UAT)    (Production)
```

**UAT環境の特徴:**<br>
- 本番と同じ構成・データで実施されることが多い<br>
- ユーザーが実際の業務フローで動作確認<br>
- ここで承認されて初めて本番リリースへ進む<br>
- 開発チームではなく、発注者側やエンドユーザーが主体<br>

**ステージング環境との違い:**<br>

| 項目 | ステージング環境 | UAT環境 |
|------|-----------------|---------|\n| **主な目的** | 技術的な最終動作確認・リハーサル | ユーザーによる業務受け入れテスト |
| **誰が使う** | 開発チーム・運用チーム | エンドユーザー・発注者 |
| **確認内容** | 本番と同じ動作をするか | 業務要件を満たすか |
| **位置づけ** | デプロイ前の最終検証 | 承認のための環境 |

**現場での運用パターン:**<br>
- **パターン1**: ステージング環境とUAT環境が別々に存在（大規模プロジェクト）<br>
- **パターン2**: 同じ環境をステージング・UAT両方の用途で使用（中小規模）<br>
- **パターン3**: ステージング→UAT の順に同じ環境で実施<br>

UAT環境は、本番一歩手前の「最終関門」として機能する重要な環境。<br>

---

### クラウドサービスの4層構造（IaaS、PaaS、SaaS、IPaaS）
クラウドサービスを「どこまでクラウド事業者が管理してくれるか」で分類した構造。<br>
下層ほど利用者の管理範囲が広く、上層ほどクラウド事業者が多くを管理してくれる。<br>

**IaaS（Infrastructure as a Service）:** 仮想的なハードウェアを提供。仮想サーバー（VM）、仮想ネットワークなど。<br>
例: Azure Virtual Machines、AWS EC2、Azure Virtual Network<br>

**PaaS（Platform as a Service）:** アプリケーション実行環境を提供。OSやミドルウェアは管理不要。<br>
例: Azure App Service、Azure Container Apps、AWS Lambda<br>

**SaaS（Software as a Service）:** 完成したソフトウェアをそのまま利用。<br>
例: Microsoft 365、Gmail、Salesforce<br>

**IPaaS（Integration Platform as a Service）:** システム間連携を簡単にするツールを提供。<br>
例: Azure Logic Apps、AWS Step Functions<br>

<div style="height:50px;"></div>

# OS・システム

### カーネル（Kernel）
OSの中核部分で、ハードウェアとアプリケーションの間を取り持つ「仲介役」。<br>
アプリケーションからのリクエスト（ファイル読み込み、メモリ確保など）を受け取り、実際のハードウェア操作を行う。<br>

**カーネルの主な役割:**<br>
- ハードウェア管理（CPU、メモリ、ディスク、ネットワーク）<br>
- リソース分配（複数のアプリにCPU・メモリを公平に割り当て）<br>
- セキュリティ管理（不正なアクセスを防止）<br>

**主なカーネルの種類:**<br>
- **Linuxカーネル**: Linux OS、Androidで使用<br>
- **Darwin（UNIXカーネル）**: macOSで使用（BSD UNIX由来）<br>
- **NTカーネル**: Windowsで使用<br>

カーネルがあることで、アプリ開発者は複雑なハードウェア制御を意識せずにプログラムを作れる。

---

### UNIX（ユニックス）
1969年にAT&Tベル研究所で開発された歴史あるOS。<br>
現代のIT業界の基盤となった設計思想と技術を持ち、多くのOSに影響を与えた。<br>
商用UNIX（Solaris、AIX、HP-UXなど）は金融機関や通信キャリアの基幹システムで今も稼働している。<br>
また、Windows以外のほぼすべてのOS（Linux、macOS、Android、iOS）がUNIXの影響を受けているので、
現代のOS設計思想の元祖とも言える。<br>

**UNIXの特徴:**<br>
- マルチタスク・マルチユーザー対応<br>
- 階層的なファイルシステム（/bin, /etc, /home など）<br>
- 小さなツールを組み合わせる哲学（パイプ、リダイレクト）<br>
- テキストベースの設定ファイル<br>

**UNIXの系統:**<br>
```
1969年 UNIX誕生（AT&T）
  │
  ├─ 商用UNIX（高額・企業向け）
  │   ├─ Sun Solaris
  │   ├─ IBM AIX
  │   └─ HP-UX
  │
  ├─ BSD系（大学で発展）
  │   ├─ FreeBSD
  │   ├─ OpenBSD
  │   └─ macOS（Darwin）
  │
  └─ Linux（1991年〜）
      └─ UNIXを参考に再実装
```

**現代のUNIX:**<br>
- **スマートフォン**: iOS（UNIX認証取得）、Android（Linux）<br>
- **デスクトップ**: macOS（正式なUNIX）<br>
- **サーバー**: Linux（UNIX系）が圧倒的シェア<br>
- **レガシーシステム**: 商用UNIXが稼働中<br>

**補足: なぜmacOSは「UNIX」と呼べるのか？**<br>

macOSは**The Open Group認証を取得した正式なUNIX**です。<br>
これは「UNIX」という商標を使用できる厳密な認証で、基準をクリアしたOSだけが取得できます。<br>
認証を得ているので「macOSは正式なUNIX」と表現できる。<br>
厳密にいうと、macOSはUNIXをベースにAppleが独自機能を多数追加したOSなので「macOSはUNIXをベースに作成されたOS」という表現も正しい。<br>

**macOSの構造:**<br>
```
┌─────────────────────────────┐
│ アプリ（Safari、Finderなど） │ ← Apple製
├─────────────────────────────┤
│ Aqua（美しいUI）            │ ← Apple製
├─────────────────────────────┤
│ macOS API・フレームワーク    │ ← Apple製
├─────────────────────────────┤
│ Darwin（UNIXカーネル）       │ ← BSD UNIX由来
└─────────────────────────────┘
```

**LinuxとUNIXの関係:**<br>
Linuxは**UNIXではない**が、**UNIX互換**。<br>
1991年、フィンランドの学生リーナス・トーバルズが「UNIXみたいなOS」を自作。<br>
UNIXのコードは使わず、動作や設計だけを参考にゼロから実装。<br>
結果的にLinuxのほうが世の中に広く普及し、サーバーOSの主流となった。<br>

**料理で例えると:**<br>
- **UNIX**: 老舗の伝統レシピ（秘伝のタレ）<br>
- **macOS**: そのレシピを使い、高級食材と美しい盛り付けを追加<br>
- **Linux**: レシピを研究して、自分で味を再現した創作料理<br>

WindowsユーザーはWSL（Windows Subsystem for Linux）を使わないと<br>
UNIX系のコマンドが使えないが、Macユーザーは標準でUNIX環境が手に入る。<br>

---

### Linux
オープンソースのOS（基本ソフト）。<br>
サーバーやクラウド環境で広く使われ、安定性や柔軟性が高い。<br>
Androidなどの一部スマートフォンもLinuxカーネルを利用している。<br>
多くのクラウドサーバーやWebサービスがLinuxで稼働している。<br>

---

### Linuxディストリビューション
Linuxカーネル（OS の核となる部分）に様々なソフトウェアを組み合わせて作られた「完成品OS」。<br>
Windows・macOSは一社が完成品として提供するが、Linuxはオープンソースのため各社・コミュニティが独自の完成品を作成。<br>

**主要なディストリビューション:**<br>
- **Ubuntu**: デスクトップ・開発者向け。現在のクラウド環境で主流<br>
- **CentOS/Rocky Linux**: サーバー・企業向け。従来は企業で広く使用<br>
- **Red Hat Enterprise Linux**: 商用サポート付きの企業向け<br>

**ディストリビューション間の主な違い:**<br>
- パッケージ管理コマンド（apt vs yum/dnf）<br>
- 設定ファイルの配置場所<br>  
- デフォルトソフトウェア・用途特化<br>

**基本的なLinuxコマンド**（ls, cd, mkdir, git等）**はどのディストリビューションでも共通。**<br>

---

### cron（クーロン）
Linuxに標準で組み込まれているシステムツールで、定期実行管理することができる。<br>
指定した時間に自動でコマンドやプログラムを実行（コマンド、スクリプト、プログラム（バッチ処理含む））。<br>
基本的にはCLI（コマンドラインインターフェース）を通じて設定する。<br>
Windows環境だとタスクスケジューラーが同様の機能を提供する。<br>

---

### オーバーヘッド
本来の処理に付随して発生する追加のコスト（処理時間やメモリ使用など）。<br>
機能を追加したり安全性を高めるとオーバーヘッドが増えることがある。<br>
通信を暗号化する処理を入れると、暗号化・復号化にかかる時間がオーバーヘッドになる。<br>

<div style="height:50px;"></div>

# プログラミング概念

### アセンブリ言語
CPUが実行する命令に非常に近い低レベル言語。<br>
高い性能やハードウェア制御が必要な場面で使われるが、記述が難しく可搬性が低い。<br>
組み込み機器やパフォーマンスが極めて重要な一部の処理で用いられる。<br>

---

### インタプリタ言語
ソースコードを逐次読みながらその場で翻訳・実行するタイプの言語。<br>
書いたコードをすぐ実行できる利便性がある反面、実行速度はコンパイル済みの言語より遅くなることがある。<br>
PythonやJavaScriptは代表的なインタプリタ言語（実行環境によってはJITコンパイルなども使われる）。<br>

---

### Node.js（ノードジェイエス）
Node.jsはJavaScriptをサーバーサイドで動かす実行環境で、外部パッケージをnpmでインストールして機能を追加するのが一般的。<br>
多くの「API（機能）」がパッケージとして提供され、簡単に組み合わせて使える。<br>
`npm install express` でWebサーバー機能を使い、`npm install axios` でHTTP通信を簡単に行える。<br>

---

### シンタックスシュガー（Syntactic Sugar）
プログラミング言語において、本質的な機能は変わらないが、より読みやすく書きやすくするための構文上の工夫のこと。<br>
「構文上の糖衣」という意味で、複雑な処理を甘く（簡単に）見せる表現方法。<br>

**特徴:**<br>
- 既存の機能を別の書き方で表現できるようにしたもの<br>
- コンパイル時や実行時には元の基本的な処理に変換される<br>
- コードの可読性や記述の簡潔性を向上させる<br>

**具体例（JavaScript）:**<br>
```javascript
// 従来の書き方 例1:
var name = person.name ? person.name : 'Guest';
// シンタックスシュガー（Null合体演算子）
var name = person.name ?? 'Guest';

// 従来の書き方 例2:
var double = function(x) {
    return x * 2;
};
// シンタックスシュガー（アロー関数）
var double = (x) => x * 2;
```

**メリット:** コードが短く簡潔になり、可読性が向上する。開発効率も上がる。<br>
**注意点:** 過度に使うと初心者には理解しにくくなる。内部的には同じ処理をしているため、パフォーマンスは基本的に変わらない。<br>

シンタックスシュガーは「砂糖で甘くする」ように、プログラミングを「甘く（簡単に）」してくれる便利な機能。<br>

---

### ビットフラグ（Bit Flag）
0と1の並びで複数の状態（ON/OFF）を1つの数値で管理する手法。<br>
各桁（ビット）が独立したフラグとして機能し、メモリ効率よく複数の設定を扱える。<br>

**具体例:**<br>
```
API取得項目の指定: 10101
→ 1桁目=ON（名前を取得）
→ 2桁目=OFF（住所は取得しない）
→ 3桁目=ON（電話番号を取得）
→ 4桁目=OFF（メールは取得しない）
→ 5桁目=ON（年齢を取得）
```

**使われる場面:**<br>
- APIのクエリパラメータ（取得項目の絞り込み）<br>
- ユーザー権限管理（読み取り、書き込み、削除などの権限）<br>
- 機能のON/OFF設定（複数機能を1つのパラメータで管理）<br>
- Linuxのファイル権限（rwx = 読み書き実行）<br>

**メリット:** 複数の設定を1つの数値で表現でき、メモリ効率が良い。パラメータ数を減らせる。<br>
**注意点:** 人間には読みにくく、ドキュメントがないと理解しづらい。桁数が増えると管理が複雑になる。<br>

レガシーシステムや性能重視のシステムでよく使われる、実務で見かける一般的な技術。<br>

---

### 浮動小数点数（Floating Point）／小数計算の誤差
コンピュータで小数を扱うときに使われる表現方法。<br>
ただし、**一部の小数（0.1、0.2など）は内部的に正確に表現できず、計算に誤差が出る**。<br>

**なぜ0.1が正確に表現できないのか？**<br>

コンピュータは2進数（0と1だけ）で数を扱います。<br>
10進数で簡単に書ける「0.1」は、2進数では無限に続く小数になってしまいます。<br>

**10進数と2進数の違い（例え）:**<br>
- **10進数での1/3**: 0.3333333...（無限に続く）<br>
- **2進数での0.1**: 0.0001100110011...（無限に続く）<br>

10進数で「1÷3」を計算すると無限小数になるのと同じように、<br>
2進数で「0.1」を表現しようとすると無限小数になります。<br>

**実際の誤差の例（JavaScript）:**<br>
```javascript
console.log(0.1 + 0.2);  // 0.30000000000000004 と表示される
console.log(0.1 + 0.2 === 0.3);  // false になる
```

**現場で注意が必要なケース:**<br>
- **金額計算**: ¥100 × 0.1（消費税10%）などの計算<br>
- **パーセント計算**: 割合や比率の計算<br>
- **科学技術計算**: 精密な数値計算が必要な場面<br>
- **等価比較**: 小数同士を `==` や `===` で比較する<br>

**誤差を検知するタイミング:**<br>
1. **変数の型を見る**: `float`, `double`, `Number`など小数型を使っている<br>
2. **計算内容を見る**: 割り算、掛け算で小数が出る可能性がある<br>
3. **要件を見る**: 「金額」「通貨」「消費税」などのワードがある<br>

**対処法:**<br>
- **整数で計算する**: 金額は「円」ではなく「銭」で計算（100円 = 10000銭）<br>
- **専用ライブラリを使う**: Decimal型、BigDecimal（Java）、decimal（Python）<br>
- **等価比較を避ける**: 差分が十分小さいかチェック（`Math.abs(a - b) < 0.0001`）<br>
- **四捨五入**: 必要な桁数で丸める（表示時や最終計算時）<br>

**現場での実例:**<br>
```
❌ 悪い例:
price = 100;
tax = price * 0.1;  // 10.000000000000001 になる可能性

✅ 良い例:
price = 100;
tax = Math.round(price * 10) / 100;  // 正確に 10 になる

または

price_in_cents = 10000;  // 100円を銭単位で
tax_in_cents = price_in_cents * 10 / 100;  // 整数計算
```

**覚えておくべきポイント:**<br>
- 小数計算は「見た目」と「内部の値」が違うことがある<br>
- お金の計算では必ず対策が必要<br>
- 単純な `==` 比較は危険<br>

この問題は**すべてのプログラミング言語に共通**しているコンピュータの根本的な制約。<br>

---

### メモリリーク（Memory Leak）
プログラムが確保したメモリを解放し忘れることで、メモリ使用量が増え続けてしまう問題。<br>
最終的にはシステムのメモリが枯渇し、アプリケーションがクラッシュしたり、システム全体が遅くなったりする。<br>

**発生する仕組み:**<br>
```
1. プログラムがメモリを確保（malloc, new など）
2. 使い終わったメモリを解放し忘れ（free, delete を呼ばない）
3. 確保されたまま放置されたメモリが積み重なる
4. 使えるメモリが減り続ける → システムが不安定に
```

**具体例:**<br>
- ループ内で毎回メモリを確保するが、解放処理を忘れている<br>
- イベントリスナーやコールバック関数を登録したまま削除しない<br>
- データベース接続やファイルハンドルを閉じずに放置<br>

**症状:**<br>
- 長時間稼働するとメモリ使用量が増え続ける<br>
- システムが徐々に遅くなる<br>
- 最終的にOut of Memoryエラーが発生<br>

**防ぐ方法:**<br>
- ガベージコレクション（GC）のある言語を使う（Java、Python、JavaScriptなど）<br>
- スマートポインタやRAII（C++）などの自動管理を活用<br>
- リソース管理を明示的に行う（try-finally、using文など）<br>
- メモリプロファイラーツールで定期的に監視<br>

**関連用語との関係:**<br>
- **ガベージコレクション（GC）**: 不要になったメモリを自動的に解放する仕組み。メモリリークを防ぐ。<br>
- **リソースリーク**: メモリ以外（ファイル、DB接続、ソケットなど）のリソース解放忘れ。<br>

現代の言語ではGCがあるためメモリリーク自体は起きにくいが、循環参照やイベントリスナーの削除忘れなどで発生することもある。<br>

---

### ガベージコレクション（Garbage Collection／GC／ジーシー）
プログラムが使わなくなったメモリを自動的に検出して解放する仕組み。<br>
開発者が手動でメモリ解放を管理する必要がなくなり、メモリリークのリスクが大幅に減る。<br>

**GCがある言語:**<br>
- Java、Python、JavaScript、C#、Go、Rubyなど<br>

**GCがない言語:**<br>
- C、C++（手動でmalloc/freeやnew/deleteを管理）<br>

**メリット:**<br>
- メモリリークが起きにくい<br>
- 開発が簡単（メモリ管理を意識しなくてよい）<br>

**デメリット:**<br>
- GC実行時にプログラムが一時停止することがある（STW: Stop The World）<br>
- メモリ使用量がやや多くなる傾向<br>

**GCがあっても発生するメモリリーク:**<br>
- 循環参照（オブジェクト同士が互いに参照し合っている）<br>
- グローバル変数やキャッシュに溜め込んだまま放置<br>
- イベントリスナーやコールバックの削除忘れ<br>

GCは便利だが万能ではなく、適切なリソース管理は依然として重要。<br>

---

### リソースリーク（Resource Leak）
メモリ以外のリソース（ファイル、データベース接続、ソケット、スレッドなど）を解放し忘れる問題。<br>
メモリリークと同様、リソースが枯渇してシステムが不安定になる。<br>

**よくある例:**<br>
- ファイルを開いたまま閉じない（ファイルハンドルリーク）<br>
- データベース接続を切断せずに放置（コネクションリーク）<br>
- ネットワークソケットを閉じない（ソケットリーク）<br>
- スレッドを終了させずに放置（スレッドリーク）<br>

**症状:**<br>
- 「Too many open files」エラー<br>
- データベース接続プールが枯渇<br>
- システムリソースが足りなくなる<br>

**防ぐ方法:**<br>
- try-finallyやusing文でリソースを確実に解放<br>
- Pythonのwith文、Javaのtry-with-resources<br>
- 接続プールやリソースプーリングの活用<br>

ガベージコレクションはメモリを自動管理するが、**ファイルやDB接続などは自動で閉じてくれない**ため、明示的な解放が必要。<br>

<div style="height:50px;"></div>

# アーキテクチャ・設計

### スケールアウト（Scale-out） / スケールイン（Scale-in）
サーバーの台数を増やして処理を分散するのがスケールアウト。<br>逆に台数を減らしてコストを下げるのがスケールイン。<br>

メリット： 同時接続数や並列処理能力を簡単に伸ばせる。可用性（冗長化）も向上する。<br>
注意点： セッション管理やデータ整合性、設定の同期が必要になることが多い。

---

### スケールアップ（Scale-up） / スケールダウン（Scale-down）
既存のサーバー自体のCPUやメモリ、ディスク容量を増やして性能を上げるのがスケールアップ。<br>逆にリソースを下げるのがスケールダウン。<br>

メリット： 単純に処理性能を上げやすく、アプリ側の設計変更が少ない場合がある。<br>
注意点： 物理的・インスタンスの上限があり、スケールアウトほど柔軟でない。ダウンタイムが発生する可能性がある。

---

### フェイルオーバー（Failover）
システム障害が発生した際に、自動的に予備系（待機系）のサーバーやシステムに切り替えて、サービスを継続する仕組み。<br>
「障害時の自動切り替え」と理解すればよい。<br>

**主な目的:** 可用性の向上（システムを止めないこと）。障害発生時のダウンタイムを最小化する。<br>

**フェイルオーバーの構成例:**<br>
```
アクティブ・スタンバイ構成（ホットスタンバイ）:
┌─────────┐
│サーバーA│  
│(稼働中) │   障害発生！
└─────────┘ 
 ↓ 切り替え         
┌─────────┐
│サーバーB│
│(待機中) │ → 稼働開始
└─────────┘


アクティブ・アクティブ構成:
┌─────────┐
│サーバーA│ ← 両方とも稼働中
│(稼働中) │    負荷分散
└─────────┘
┌─────────┐
│サーバーB│ ← Aが落ちても
│(稼働中) │    Bが全て処理
└─────────┘
```

**スケールアウトとの違い:**<br>

| 項目 | スケールアウト | フェイルオーバー |
|------|---------------|-----------------|
| **主な目的** | 性能向上・負荷分散 | 可用性向上・障害対策 |
| **サーバーの役割** | 全台が常に稼働して負荷分散 | 予備系は待機（または軽負荷） |
| **障害時の動作** | 残りのサーバーで処理継続 | 予備系へ自動切り替え |
| **導入理由** | 「遅い」を解決 | 「止まらない」を実現 |

**重要な違い:**<br>
- **スケールアウト**: 複数サーバーが同時に処理して性能を上げる。結果的に1台落ちても大丈夫だが、本来の目的は「速くすること」。<br>
- **フェイルオーバー**: 障害時に切り替えることが目的。性能向上は副次的効果。<br>

**実際の関係性:**<br>
スケールアウト構成（複数サーバー）を組むと、自然とフェイルオーバー能力も得られることが多い。<br>
しかし、フェイルオーバーのために必ずしもスケールアウトが必要なわけではない（アクティブ・スタンバイ構成は2台だけ）。<br>

**使われる場面:**<br>
- データベースサーバー（マスター・スレーブ構成）<br>
- Webサーバー（ロードバランサー配下で自動切り替え）<br>
- ネットワーク機器（ルーター、ファイアウォールの冗長化）<br>
- クラウドサービス（AWSのMulti-AZ、Azureの可用性セット）<br>

**フェイルバック:**<br>
障害が復旧した後、元の主系（サーバーA）に戻す作業をフェイルバックという。<br>
自動で戻す場合もあれば、手動で戻す場合もある。<br>

---

### クラスタ構成（クラスター）／クラスタリング
複数のサーバーやノードを**1つのまとまり（クラスター）として連携させる構成**。<br>
アクティブ・アクティブでもアクティブ・スタンバイでも、外からは「1つのサービス」として見える設計。<br>
**性能向上・可用性・運用性など、複合的な目的**で導入されることが多い。<br>

**よくある目的:**<br>
- **可用性**（止まらない）を上げる<br>
- **性能**（さばける量）を上げる<br>
- **運用性**（メンテしやすい）を上げる<br>

**代表的なクラスタの形:**<br>
- **アクティブ・アクティブ**: 全台稼働で負荷分散（性能向上に強い）<br>
- **アクティブ・スタンバイ**: 片方稼働・片方待機（可用性重視）<br>

**スケールアウトとの関係:**<br>
- クラスタ構成は**複数台で動かす「仕組み」**<br>
- スケールアウトは**台数を増やす「手段」**<br>
→ つまり、スケールアウトはクラスタリングの一部として行われることが多い。<br>

**フェイルオーバーとの関係:**<br>
- クラスタ構成の中に**フェイルオーバー機能**が含まれることが多い（自動切り替え）。<br>

**冗長化との違い:**<br>
- **冗長化**: 基本的に**可用性（止まらない）目的が中心**。性能向上は主目的ではない。<br>
- **クラスタ構成**: 可用性だけでなく、**性能向上や負荷分散も含む**設計。<br>

**「クラスタ○○」の読み方:**<br>
クラスタDB、クラスタストレージなど「クラスタ○○」と呼ばれる場合、<br>
**複数台で構成された○○（HA・性能・負荷分散など複合的な目的）** という意味。<br>
単純な冗長化だけでなく、性能面の向上も含む場合が多い。<br>

**使われる場面:**<br>
- Webサーバーの冗長化（ロードバランサー配下）<br>
- データベースの冗長化（クラスタDB）<br>
- 共有ストレージの冗長化<br>

**注意点:**<br>
- セッション共有やデータ同期など、**複数台で整合性を保つ設計**が必要。<br>
- 構成が複雑になる分、運用コストは上がりやすい。<br>

「複数台で1つのシステムを作る考え方」そのものがクラスタ構成。<br>

---

### DevOps（デブオプス）
Development（開発）とOperations（運用）を組み合わせた造語。<br>
開発チームと運用チームの協力を促進する管理体制・文化・手法の総称。<br>
特定のサービスやツールではなく、組織運営の考え方や哲学を指す。<br>

**従来の問題:** 開発と運用が分離されていて、コミュニケーション不足や対立が発生。<br>
**DevOpsの解決策:** チーム間の壁を取り払い、共通目標に向けて協力する文化を醸成。<br>

**実践例:** CI/CD（自動テスト・自動デプロイ）、監視・フィードバック、アジャイル開発<br>
**関連ツール:** Azure DevOps、Jenkins、Docker、Kubernetesなど（ツール自体がDevOpsではない）<br>

---

### UAT環境（User Acceptance Test／ユーエーティー環境）
**別名:** 受け入れ環境、ユーザー受入テスト環境、承認環境<br>

User Acceptance Testの略。<br>
本番リリース前にユーザー（または発注者・利用部門）が最終確認を行うための検証環境。<br>
開発したシステムが要件を満たしているか、実際の業務で使えるかを確認する最終ステップ。

**環境の流れ（あくまで一般的な例）:**<br>
```
開発環境 → STG環境 → UAT環境 → 本番環境
(Dev)      (STG)    (UAT)    (Production)
```

**UAT環境の特徴:**<br>
- 本番と同じ構成・データで実施されることが多い<br>
- ユーザーが実際の業務フローで動作確認<br>
- ここで承認されて初めて本番リリースへ進む<br>
- 開発チームではなく、発注者側やエンドユーザーが主体<br>

**ステージング環境との違い:**<br>

| 項目 | ステージング環境 | UAT環境 |
|------|-----------------|---------|
| **主な目的** | 技術的な最終動作確認・リハーサル | ユーザーによる業務受け入れテスト |
| **誰が使う** | 開発チーム・運用チーム | エンドユーザー・発注者 |
| **確認内容** | 本番と同じ動作をするか | 業務要件を満たすか |
| **位置づけ** | デプロイ前の最終検証 | 承認のための環境 |

**現場での運用パターン:**<br>
- **パターン1**: ステージング環境とUAT環境が別々に存在（大規模プロジェクト）<br>
- **パターン2**: 同じ環境をステージング・UAT両方の用途で使用（中小規模）<br>
- **パターン3**: ステージング→UAT の順に同じ環境で実施<br>

UAT環境は、本番一歩手前の「最終関門」として機能する重要な環境。<br>

---

### クラウドサービスの4層構造（IaaS、PaaS、SaaS、IPaaS）
クラウドサービスを「どこまでクラウド事業者が管理してくれるか」で分類した構造。<br>
下層ほど利用者の管理範囲が広く、上層ほどクラウド事業者が多くを管理してくれる。<br>

**IaaS（Infrastructure as a Service）:** 仮想的なハードウェアを提供。仮想サーバー（VM）、仮想ネットワークなど。<br>
例: Azure Virtual Machines、AWS EC2、Azure Virtual Network<br>

**PaaS（Platform as a Service）:** アプリケーション実行環境を提供。OSやミドルウェアは管理不要。<br>
例: Azure App Service、Azure Container Apps、AWS Lambda<br>

**SaaS（Software as a Service）:** 完成したソフトウェアをそのまま利用。<br>
例: Microsoft 365、Gmail、Salesforce<br>

**IPaaS（Integration Platform as a Service）:** システム間連携を簡単にするツールを提供。<br>
例: Azure Logic Apps、AWS Step Functions<br>

<div style="height:50px;"></div>

<div style="height:50px;"></div>

# 認証・セキュリティ基礎

### QA（Quality Assurance／キューエー）
Quality Assuranceの略。<br>
ソフトウェアの品質を保証するためのテストや検証の総称。<br>
バグ検出、動作確認、受け入れテストなどを含む活動全般。QAは開発の信頼性を高める重要な役割を持つ。<br>
リリース前の自動テストや手動確認によって不具合を防ぐ。<br>

---

### OAuth（Open Authorization／オーオース）
他サービスの認証機能を使ってログインさせる仕組み（認可の仕組み）。<br>
ユーザーのパスワードを相手サービスに渡さずに認可を与えることができる。<br>
Webサイトに「Googleでログイン」ボタンがある場合、OAuthで連携している。<br>

---

### JWT（JSON Web Token／ジョット）
認証などに利用。ユーザー情報などを安全にやり取りするための短いトークン形式のデータ。<br>
サーバーが発行し、クライアントが保持してリクエストごとにトークンを送ることで本人確認ができる。<br>
改ざん防止のため署名される。<br>
ログイン後にサーバーが発行するトークンを保存してAPI呼び出し時に使う。<br>

- [JWTについての詳細ページ](security/jwt.md)

---

### ベーシック認証
最も単純なHTTP認証方式。<br>
ユーザー名とパスワードをBase64でエンコードして送る（暗号化ではない）。<br>
シンプルだが安全性は低く、HTTPSと併用するか別の方式が推奨。<br>
社内システムの簡易保護に使われることがあるが、公開サービスでは避けるべき。<br>

---

### SSL/TLS（Secure Sockets Layer/Transport Layer Security、エスエスエル/ティーエルエス）
WebサイトがHTTPSで安全に通信するための証明書技術。<br>
通信内容を暗号化し、サーバーの身元を証明することで、盗聴や改ざん、なりすましを防ぐ。<br>
現在はSSLよりも安全性の高いTLSが主流になっており、名残で「SSL証明書」と呼ばれることもあるが、実際はTLS証明書。<br>
- [SSL/TLSの詳細ページ](security/ssl_tls.md)
---

### クライアント認証
サーバーが利用者（クライアント）を証明書で確認する仕組み。<br>
通常はサーバー証明書でサーバー側を確認するが、クライアント証明書を用いると強固なアクセス制御ができる。<br>
社内PCに証明書を配布し、証明書を持たない端末はサービスにアクセスできないようにする。<br>
