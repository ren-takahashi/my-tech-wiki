# データベース関連

### テーブル設計とリレーションシップ
テーブル間の関係（カーディナリティ）をどう設計するかのパターン集。<br>
**データベース設計の最初のステップ。まずエンティティ間の関係性を明確にする。**<br>

**主な内容:**<br>
- 1対1の関係（例：ユーザーと詳細プロフィール）<br>
- 1対多の関係（例：ユーザーと投稿）← 最も基本的<br>
- 多対多の関係（例：学生と授業）← 中間テーブルの理解が重要<br>
- 自己参照（例：従業員と上司、SNSフォロー）<br>

[テーブル設計とリレーションシップ（1対1、1対多、多対多、自己参照）](table_design.md)

---

### 正規化（Normalization）
データベース設計の基本技法で、データの冗長性を排除し、整合性を保つためにテーブルを適切に分割する手法。<br>
**リレーションシップが決まったら、次にデータの重複を排除していく。**<br>
第1正規形（1NF）、第2正規形（2NF）、第3正規形（3NF）と段階的に進める。<br>
非正規形のテーブルから始めて、繰り返し項目の排除 → 部分関数従属の排除 → 推移的関数従属の排除という流れで整理していく。<br>

**正規化のメリット:**<br>
- データの重複が減り、ディスク容量を節約できる<br>
- 更新時の不整合（更新異常）を防げる<br>
- データの一貫性が保たれる<br>

**進め方:**<br>
1. 必要なカラムを洗い出す<br>
2. とりあえず1つのテーブルにまとめる（非正規形）<br>
3. 1NF → 2NF → 3NF と段階的に正規化していく<br>

**注意点:**<br>
- 過度な正規化はJOINが増えてパフォーマンスが悪化する場合がある<br>
- 読み込み重視のシステムでは意図的に非正規化することも<br>

[正規化の詳細ページ（第1〜第3正規形、JOIN解説付き）](normalization.md)

---

### インデックス（Index）／インデックス最適化
データベースの検索速度を劇的に向上させる仕組み。<br>
**テーブル設計ができて、実際にクエリを実行してみたら遅い箇所に張る。**<br>
本の「索引」のようなもので、適切に設定すれば数秒かかるクエリが数ミリ秒で終わることもある。<br>

**重要性:**<br>
実務で「クエリが遅い」問題の9割はインデックス不足が原因。<br>
パフォーマンスチューニングの第一手段であり、システムの体感速度を左右する最重要テーマ。<br>

**実務で重要なポイント:**<br>
- WHERE、JOIN、ORDER BY で使うカラムに張る<br>
- 複合インデックスの順序が重要<br>
- EXPLAIN（実行計画）でインデックスが使われているか確認<br>

[インデックス最適化の詳細ページ（種類、張り方、EXPLAIN、実務tips）](index_optimization.md)

---

### トランザクション（Transaction）
複数のデータベース操作をひとまとまりの処理として扱う仕組み。<br>
**実装段階で、複数の操作をまとめて処理する必要が出てきたら考える。**<br>
「全て成功」または「全て失敗（ロールバック）」のいずれかを保証し、データの整合性を守る。<br>

**重要性:**<br>
銀行の送金処理など、途中で処理が止まったら困る場面で必須。<br>
ACID特性（原子性・一貫性・独立性・永続性）を理解することで、正しいトランザクション設計ができる。<br>

**実務で重要なポイント:**<br>
- 分離レベルの選択（READ COMMITTED が基本、用途に応じて調整）<br>
- デッドロックの理解と回避<br>
- 長時間トランザクションの危険性<br>

[トランザクションの詳細ページ（ACID、分離レベル、ロック、デッドロック）](transaction.md)

---

### 基本SQL集
基本的なSQLをまとめたチートシート。<br>
SELECT、JOIN、集計、INSERT/UPDATE/DELETEなど、実務で頻繁に使うSQL文をコピペできる形でまとめている。<br>

[基本SQL集](basic_sql.md)
