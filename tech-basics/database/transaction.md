# トランザクション（Transaction）

## トランザクションとは？

複数のデータベース操作を**ひとまとまりの処理単位**として扱う仕組み。<br>
「全ての操作が成功」または「全ての操作が失敗（元に戻す）」のいずれかを保証する。<br>

**身近な例: 銀行の送金**<br>
```
1. A さんの口座から 10,000 円を引く
2. B さんの口座に 10,000 円を足す
```

もし 1 だけ成功して 2 が失敗したら、お金が消えてしまう。<br>
トランザクションは「両方成功」または「両方キャンセル」を保証し、こうした問題を防ぐ。<br>

---

## ACID（アシッド）特性

トランザクションが満たすべき4つの特性。データベースの信頼性の基盤。<br>

### A - Atomicity（原子性／アトミシティ）
トランザクション内の操作は**全て成功するか、全て失敗するか**のどちらか。<br>
途中で止まって中途半端な状態にならない。<br>

**例:**<br>
- ○ 送金処理が全て完了<br>
- ○ エラーで全てロールバック（元に戻る）<br>
- × 引き落としだけ成功して入金が失敗（こうはならない）<br>

---

### C - Consistency（一貫性／コンシステンシー）
トランザクション前後でデータの整合性が保たれる。<br>
業務ルールや制約（外部キー、CHECK制約など）が守られる。<br>

**例:**<br>
- 在庫数がマイナスにならない<br>
- 年齢が 0〜150 の範囲内<br>
- 注文テーブルに存在しない顧客IDは登録できない<br>

---

### I - Isolation（独立性・分離性／アイソレーション）
複数のトランザクションが同時実行されても、互いに影響を与えない。<br>
あたかも順番に実行されたかのように見える。<br>

**問題例（分離レベルが低い場合）:**<br>
- **ダーティリード**: 他のトランザクションの未確定データを読んでしまう<br>
- **ノンリピータブルリード**: 同じデータを2回読んだら値が変わっていた<br>
- **ファントムリード**: 範囲検索の結果が途中で変わる<br>

→ **分離レベル**で制御する（後述）<br>

---

### D - Durability（永続性／デュラビリティ）
トランザクションがコミット（確定）されたら、システムが落ちても**データは永続的に保存**される。<br>
データベースはディスクに書き込み、障害時もログから復旧できる。<br>

**実務での意味:**<br>
「送金完了」と表示されたら、その直後にサーバーが落ちてもデータは消えない。<br>

---

## トランザクションの基本操作

### BEGIN（トランザクション開始）
```sql
BEGIN;  -- または START TRANSACTION;
```

### COMMIT（確定）
```sql
COMMIT;  -- 変更を確定して保存
```

### ROLLBACK（取り消し）
```sql
ROLLBACK;  -- 変更を全て破棄して元に戻す
```

**実務例:**<br>
```sql
BEGIN;

UPDATE accounts SET balance = balance - 10000 WHERE user_id = 1;  -- A さんから引く
UPDATE accounts SET balance = balance + 10000 WHERE user_id = 2;  -- B さんに足す

-- 問題なければ
COMMIT;

-- エラーが起きたら
ROLLBACK;
```

---

## 分離レベル（Isolation Level）

トランザクション同士がどこまで独立するかを制御する設定。<br>
4段階あり、**厳しいほど安全だが、パフォーマンスは下がる**。<br>

### 分離レベル一覧（厳しい順）

| 分離レベル | ダーティリード | ノンリピータブルリード | ファントムリード | 特徴 |
|-----------|--------------|---------------------|----------------|------|
| **SERIALIZABLE** | 防ぐ | 防ぐ | 防ぐ | 最も厳格。完全に順次実行されたかのように動作 |
| **REPEATABLE READ** | 防ぐ | 防ぐ | 起こる | 同じ行を再読込しても値が変わらない（MySQL のデフォルト）|
| **READ COMMITTED** | 防ぐ | 起こる | 起こる | 確定済みデータのみ読む（PostgreSQL のデフォルト）|
| **READ UNCOMMITTED** | 起こる | 起こる | 起こる | 最も緩い。未確定データも読む |

### 実務での選び方

**基本は READ COMMITTED**<br>
- 多くのシステムで十分な安全性<br>
- パフォーマンスとのバランスが良い<br>

**REPEATABLE READ や SERIALIZABLE が必要なケース**<br>
- 金融系システム（残高計算など、絶対に不整合が許されない）<br>
- 在庫管理（複数人が同時に在庫を更新する）<br>

**READ UNCOMMITTED は基本的に使わない**<br>
- データの正確性が保証されないため、実務では危険<br>

### 設定方法（例: PostgreSQL）

```sql
-- トランザクションごとに設定
BEGIN TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- または
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

---

## ロックとデッドロック

### ロックとは？

複数のトランザクションが同じデータを同時に操作する際の**交通整理**。<br>

**2種類のロック:**<br>

| ロック種類 | 別名 | 説明 | 複数同時可能？ |
|-----------|------|------|--------------|
| **共有ロック（S）** | 読み取りロック | データを読むためのロック | ○（他の読み取りと共存できる）|
| **排他ロック（X）** | 書き込みロック | データを更新するためのロック | ×（他のロックと共存不可）|

**ロックのルール:**<br>
- 読み取り中は、他の人も読める（共有ロック同士はOK）<br>
- 書き込み中は、他の人は読むことも書くこともできない（排他ロック発動中）<br>

---

### デッドロック（Deadlock）

2つ以上のトランザクションが**互いにロック解除を待ち続ける**状態。<br>

**デッドロックの例:**<br>
```
トランザクション A:
  1. テーブル X をロック
  2. テーブル Y をロックしようとする → 待機

トランザクション B:
  1. テーブル Y をロック
  2. テーブル X をロックしようとする → 待機

→ A は B のロック解除を待ち、B は A のロック解除を待つ
→ 永遠に進まない（デッドロック）
```

**データベースの対処:**<br>
デッドロックを検出したら、一方のトランザクションを**強制的にロールバック**する。<br>
エラーメッセージ: `ERROR: deadlock detected`<br>

---

### デッドロックの回避方法

**1. テーブルへのアクセス順序を統一する**<br>
```sql
-- ○ 良い例: 常に A → B の順
BEGIN;
UPDATE table_a SET ...;
UPDATE table_b SET ...;
COMMIT;

-- × 悪い例: あるトランザクションは A → B、別のトランザクションは B → A
```

**2. トランザクションを短くする**<br>
ロックを保持する時間が短いほど、衝突の可能性が減る。<br>

**3. 適切な分離レベルを選ぶ**<br>
SERIALIZABLE は安全だが、デッドロックが起きやすい。<br>

**4. リトライロジックを実装する**<br>
デッドロックが起きたら、自動的に再試行する仕組みを入れる。<br>

---

## 楽観的ロック vs 悲観的ロック

### 悲観的ロック（Pessimistic Lock）

「衝突は必ず起こる」前提。先にロックを取得してから処理する。<br>

**使い方（PostgreSQL / MySQL）:**<br>
```sql
BEGIN;

-- FOR UPDATE で排他ロック
SELECT * FROM products WHERE id = 1 FOR UPDATE;

-- この間、他のトランザクションはこの行を更新できない
UPDATE products SET stock = stock - 1 WHERE id = 1;

COMMIT;
```

**向いている場面:**<br>
- 衝突が頻繁に起こる（在庫管理、チケット予約など）<br>
- 確実にロックしたい（金融システム）<br>

**デメリット:**<br>
- ロック待ちでパフォーマンスが落ちる<br>
- デッドロックのリスク<br>

---

### 楽観的ロック（Optimistic Lock）

「衝突は滅多に起こらない」前提。ロックせずに処理し、更新時に衝突をチェック。<br>

**使い方（バージョン番号方式）:**<br>
```sql
-- 1. 読み取り時にバージョンも取得
SELECT id, name, stock, version FROM products WHERE id = 1;
-- 結果: stock=10, version=5

-- 2. 更新時にバージョンが変わっていないか確認
UPDATE products 
SET stock = 9, version = version + 1 
WHERE id = 1 AND version = 5;

-- もし version が変わっていたら（他の人が先に更新した）、UPDATE は 0 行に影響
-- → アプリ側で「他の人が更新しました。再読込してください」エラーを出す
```

**向いている場面:**<br>
- 衝突が滅多に起こらない（ブログ記事の編集など）<br>
- 長時間トランザクションを避けたい（ユーザーが画面で入力中）<br>

**デメリット:**<br>
- 衝突時はアプリ側でリトライ処理が必要<br>
- 高頻度の衝突には向かない<br>

---

## 実務での注意点

### 1. 長時間トランザクションは危険

**問題点:**<br>
- 他のトランザクションがロック待ちで止まる<br>
- デッドロックのリスクが上がる<br>
- データベース接続を占有してしまう<br>

**悪い例:**<br>
```sql
BEGIN;
UPDATE users SET status = 'processing' WHERE id = 1;
-- ここで外部API呼び出し（数秒〜数十秒かかる）
-- 他のトランザクションはずっと待たされる
COMMIT;
```

**良い例:**<br>
```sql
-- 1. 先にステータスだけ更新してコミット
BEGIN;
UPDATE users SET status = 'processing' WHERE id = 1;
COMMIT;

-- 2. 外部API呼び出し（トランザクション外）
call_external_api();

-- 3. 結果を反映
BEGIN;
UPDATE users SET status = 'completed', result = '...' WHERE id = 1;
COMMIT;
```

---

### 2. 自動コミットに注意

多くのデータベースクライアントは**自動コミット**がデフォルト。<br>
1つのSQLごとに自動でトランザクションが確定される。<br>

**自動コミットONの場合:**<br>
```sql
UPDATE accounts SET balance = balance - 10000 WHERE user_id = 1;  -- 即座にコミット
UPDATE accounts SET balance = balance + 10000 WHERE user_id = 2;  -- 即座にコミット
-- 途中でエラーが起きても、1つ目は戻らない（危険）
```

**明示的にトランザクションを使う:**<br>
```sql
BEGIN;  -- ここから自動コミットは無効化される
UPDATE accounts SET balance = balance - 10000 WHERE user_id = 1;
UPDATE accounts SET balance = balance + 10000 WHERE user_id = 2;
COMMIT;  -- まとめて確定
```

---

### 3. トランザクション内でやってはいけないこと

- **外部API呼び出し**（時間がかかる。タイムアウトのリスク）<br>
- **ファイル操作**（DB外のリソース。ロールバックできない）<br>
- **メール送信**（送信後にロールバックしても取り消せない）<br>
- **長時間の計算処理**（ロックを長時間保持してしまう）<br>

**基本方針:**<br>
トランザクションは**データベース操作のみ**に限定する。<br>

---

## まとめ

| 項目 | ポイント |
|------|---------|
| **ACID特性** | 原子性・一貫性・独立性・永続性。トランザクションの基本 |
| **分離レベル** | 基本は READ COMMITTED。金融系は REPEATABLE READ 以上 |
| **ロック** | 共有ロック（読み取り）と排他ロック（書き込み）を理解する |
| **デッドロック** | テーブルアクセス順序を統一、トランザクションを短くして回避 |
| **楽観的 vs 悲観的** | 衝突頻度で使い分け。在庫管理は悲観的、記事編集は楽観的 |
| **実務の鉄則** | 長時間トランザクションは避ける、外部API呼び出しは外に出す |

トランザクションはデータの整合性を守る最重要機能。<br>
ACID特性と分離レベルを理解し、適切に使い分けることが実務では必須。<br>
