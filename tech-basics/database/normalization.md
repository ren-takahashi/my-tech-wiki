# データベース正規化（Normalization）

データベースのテーブル設計を整理して、**データの重複や矛盾をなくす**ためのルール。<br>
「正規化されていない」テーブルは一見便利に見えるが、運用していくうちに必ず問題が起きる。<br>

<div style="height:50px;"></div>

# なぜ正規化が必要なのか？

まず、正規化されていない「ダメなテーブル」を見てみましょう。<br>

**注文テーブル（正規化されていない状態）:**<br>

| 注文ID | 顧客名 | 顧客住所 | 商品名 | 商品単価 | 数量 |
|--------|--------|---------|--------|---------|------|
| 1 | 田中太郎 | 東京都新宿区 | ノートPC | 100000 | 1 |
| 2 | 田中太郎 | 東京都新宿区 | マウス | 3000 | 2 |
| 3 | 鈴木花子 | 大阪府大阪市 | ノートPC | 100000 | 1 |
| 4 | 田中太郎 | 東京都渋谷区 | キーボード | 5000 | 1 |

**このテーブルの問題点:**<br>

**1. データの重複（冗長性）:**<br>
「田中太郎」「東京都新宿区」「ノートPC」「100000」が何度も繰り返されている。<br>
データ量が増えると無駄にデータベースの容量を消費する。<br>

**2. 更新時の矛盾（更新異常）:**<br>
田中太郎が引っ越した場合、注文ID 1, 2は「新宿区」のまま、注文ID 4は「渋谷区」に変わっている。<br>
→ **どれが正しい住所なのか分からなくなる**。<br>

**3. 削除時のデータ消失（削除異常）:**<br>
鈴木花子の注文（注文ID 3）を削除すると、「鈴木花子」という顧客情報自体が消えてしまう。<br>
→ **注文を消しただけなのに、顧客がいなくなる**。<br>

**4. 追加時の問題（挿入異常）:**<br>
まだ注文していない新しい顧客を登録したくても、注文IDがないと登録できない。<br>
→ **注文しないと顧客を登録できない**。<br>

正規化は、こうした問題を段階的に解消していく作業。<br>

<div style="height:50px;"></div>

# 正規化のステップ
まずは一旦、正規化されていない状態のテーブル設計を作り、そこから順番に正規化していくイメージ。<br>

## 第1正規形（1NF）

**ルール: 1つのセルに1つの値だけ入れる（繰り返しをなくす）**<br>

**❌ 第1正規形になっていない例:**<br>

| 注文ID | 顧客名 | 商品名 |
|--------|--------|--------|
| 1 | 田中太郎 | ノートPC, マウス |
| 2 | 鈴木花子 | キーボード |

「商品名」にカンマ区切りで複数の値が入っている。<br>
これだと「田中太郎がノートPCを買った注文」だけを検索するのが非常に難しい。<br>

**✅ 第1正規形にした例:**<br>

| 注文ID | 顧客名 | 商品名 |
|--------|--------|--------|
| 1 | 田中太郎 | ノートPC |
| 1 | 田中太郎 | マウス |
| 2 | 鈴木花子 | キーボード |

**ポイント:** 1つのセルに1つの値。行が増えてもOK。<br>

**第1正規形のまとめ:**<br>
- セルの中にカンマ区切りや複数の値を入れない<br>
- 1行1データにする<br>
- これだけで検索やフィルタリングが格段に楽になる<br>

---

<div style="height:30px;"></div>

## 第2正規形（2NF）

**ルール: テーブルの「主キー全体」に依存しないデータを別テーブルに分ける**<br>

少し難しくなるので、具体例で見ていきましょう。<br>

**❌ 第1正規形だが、第2正規形ではない例:**<br>

| 注文ID | 商品ID | 顧客名 | 商品名 | 商品単価 | 数量 |
|--------|--------|--------|--------|---------|------|
| 1 | 101 | 田中太郎 | ノートPC | 100000 | 1 |
| 1 | 102 | 田中太郎 | マウス | 3000 | 2 |
| 2 | 101 | 鈴木花子 | ノートPC | 100000 | 1 |

このテーブルでは「注文ID + 商品ID」の組み合わせが主キー（1行を特定するカギ）。<br>

ここで考えてみてください：<br>
- 「顧客名」は**注文IDだけ**で決まる（商品IDは関係ない）<br>
- 「商品名」「商品単価」は**商品IDだけ**で決まる（注文IDは関係ない）<br>
- 「数量」は**注文ID＋商品ID**の両方で決まる<br>

つまり、「顧客名」「商品名」「商品単価」は主キーの**一部だけ**に依存している。<br>
→ これを「部分関数従属」と言って、これが問題の原因。<br>

**✅ 第2正規形にした例:**<br>

テーブルを分けて、それぞれが適切なキーに依存するようにする。<br>

**注文テーブル:**<br>

| 注文ID | 顧客名 |
|--------|--------|
| 1 | 田中太郎 |
| 2 | 鈴木花子 |

**商品テーブル:**<br>

| 商品ID | 商品名 | 商品単価 |
|--------|--------|---------|
| 101 | ノートPC | 100000 |
| 102 | マウス | 3000 |

**注文明細テーブル:**<br>

| 注文ID | 商品ID | 数量 |
|--------|--------|------|
| 1 | 101 | 1 |
| 1 | 102 | 2 |
| 2 | 101 | 1 |

**何が改善されたか:**<br>
- 「ノートPC 100000円」という情報は1か所だけに存在<br>
- 商品の価格を変えたいときは商品テーブルの1行を更新するだけ<br>
- 顧客情報も注文テーブルの1行を更新するだけ<br>

**第2正規形のまとめ:**<br>
- 主キーの一部だけに依存するデータを別テーブルに分ける<br>
- 「このデータは本当にこのテーブルにあるべき？」と考える<br>
- テーブルが増える代わりに、データの重複がなくなる<br>

---

<div style="height:30px;"></div>

## 第3正規形（3NF）

**ルール: 主キー以外の列に依存しているデータを別テーブルに分ける**<br>

**❌ 第2正規形だが、第3正規形ではない例:**<br>

**注文テーブル:**<br>

| 注文ID | 顧客ID | 顧客名 | 顧客住所 |
|--------|--------|--------|---------|
| 1 | C001 | 田中太郎 | 東京都新宿区 |
| 2 | C001 | 田中太郎 | 東京都新宿区 |
| 3 | C002 | 鈴木花子 | 大阪府大阪市 |

ここで考えてみてください：<br>
- 「顧客名」「顧客住所」は**顧客ID**で決まる（注文IDからではない）<br>
- つまり、主キー（注文ID）ではなく、別の列（顧客ID）に依存している<br>

→ これを「推移的関数従属」と言う。難しい言葉だが、要は**「主キー以外の列から決まるデータがある」**ということ。<br>

**✅ 第3正規形にした例:**<br>

**注文テーブル:**<br>

| 注文ID | 顧客ID |
|--------|--------|
| 1 | C001 |
| 2 | C001 |
| 3 | C002 |

**顧客テーブル:**<br>

| 顧客ID | 顧客名 | 顧客住所 |
|--------|--------|---------|
| C001 | 田中太郎 | 東京都新宿区 |
| C002 | 鈴木花子 | 大阪府大阪市 |

**何が改善されたか:**<br>
- 田中太郎の住所は顧客テーブルの1行だけ<br>
- 引っ越したら顧客テーブルの1行を更新するだけ<br>
- 全ての注文に正しい住所が反映される<br>

**第3正規形のまとめ:**<br>
- 主キー以外の列に依存するデータを別テーブルに分ける<br>
- 「この列は、主キーから直接決まるか？」と考える<br>
- 間接的に決まるなら、別テーブルに分離する<br>

<div style="height:50px;"></div>

# 正規化した結果の全体像

**最終的なテーブル構成:**<br>

```
【顧客テーブル】
  顧客ID（主キー）, 顧客名, 顧客住所

【商品テーブル】
  商品ID（主キー）, 商品名, 商品単価

【注文テーブル】
  注文ID（主キー）, 顧客ID（外部キー → 顧客テーブル）

【注文明細テーブル】
  注文ID（外部キー → 注文テーブル）, 商品ID（外部キー → 商品テーブル）, 数量
```

**最初の1つだったテーブルが4つに分かれた。**<br>
テーブルが増えて面倒に感じるかもしれないが、これによって：<br>
- データの重複がゼロになった<br>
- 更新は1か所だけでOK<br>
- 顧客だけの登録、商品だけの登録ができるようになった<br>

<div style="height:50px;"></div>

# 分けたテーブルをどうやって一緒に見るか？（テーブル結合）

分けたテーブルの情報で「注文の一覧を全部まとめて見たい」時には、 **テーブル結合（JOIN）** をします。<br>

**JOINとは:**<br>
複数のテーブルを「共通の列」をキーにして、くっつけて1つの結果として取り出す仕組み。<br>

**イメージ:**<br>
```
注文テーブル        顧客テーブル
┌────┬───┐      ┌───┬────┬────┐
│注文│顧客│      │顧客│顧客│顧客│
│ ID │ ID │  ←→  │ ID │ 名 │住所│
├────┼───┤      ├───┼────┼────┤
│  1 │C001│      │C001│田中│東京│
│  2 │C002│      │C002│鈴木│大阪│
└────┴───┘      └───┴────┴────┘

  「顧客ID」が共通 → ここをキーにして結合
```

**SQLの書き方:**<br>
```sql
-- 注文テーブルと顧客テーブルを結合して、注文一覧を取得
SELECT
    注文.注文ID,
    顧客.顧客名,
    顧客.顧客住所
FROM 注文
JOIN 顧客 ON 注文.顧客ID = 顧客.顧客ID;
```

**読み方（日本語に訳すと）:**<br>
```
SELECT（取り出す）
    注文テーブルの注文ID,
    顧客テーブルの顧客名,
    顧客テーブルの顧客住所
FROM（どこから？）注文テーブル
JOIN（くっつける）顧客テーブル
ON（くっつける条件）注文の顧客ID = 顧客の顧客ID
```

**結果:**<br>

| 注文ID | 顧客名 | 顧客住所 |
|--------|--------|---------|
| 1 | 田中太郎 | 東京都新宿区 |
| 2 | 鈴木花子 | 大阪府大阪市 |

正規化前の1つのテーブルと同じ見た目のデータが取り出せる。<br>
つまり、**保存するときは分けて、見るときはJOINでくっつける**。<br>

---

<div style="height:30px;"></div>

### 複数テーブルの結合

注文一覧に商品名も含めたい場合は、JOINを重ねて書く。<br>

```sql
SELECT
    注文.注文ID,
    顧客.顧客名,
    商品.商品名,
    商品.商品単価,
    注文明細.数量
FROM 注文
JOIN 顧客 ON 注文.顧客ID = 顧客.顧客ID
JOIN 注文明細 ON 注文.注文ID = 注文明細.注文ID
JOIN 商品 ON 注文明細.商品ID = 商品.商品ID;
```

**読み方:**<br>
```
注文テーブルをベースに、
  → 顧客テーブルを顧客IDでくっつけて
  → 注文明細テーブルを注文IDでくっつけて
  → 商品テーブルを商品IDでくっつけて
取り出す
```

**結果:**<br>

| 注文ID | 顧客名 | 商品名 | 商品単価 | 数量 |
|--------|--------|--------|---------|------|
| 1 | 田中太郎 | ノートPC | 100000 | 1 |
| 1 | 田中太郎 | マウス | 3000 | 2 |
| 2 | 鈴木花子 | ノートPC | 100000 | 1 |

JOINは「共通のIDを手がかりに、テーブル同士をくっつける」だけ。<br>
慣れるまでは図を描いて「どのテーブルのどの列が繋がるか」を確認すると分かりやすい。<br>

<div style="height:50px;"></div>

# 現場での正規化

### どこまで正規化するか？

実務では**第3正規形まで**が一般的。<br>
第4正規形以降もあるが、ほとんどの現場では第3正規形で十分。<br>

---

### あえて正規化しない場合（非正規化）

パフォーマンスを優先してあえてテーブルを分けないこともある。<br>

**非正規化する理由:**<br>
- JOINが多くなると処理が遅くなる<br>
- 大量データの読み込み速度を優先したい<br>
- レポートや集計用のテーブル（読み取り専用）<br>

**よくある例:**<br>
- **集計用テーブル**: 毎回JOINして計算するのが遅いので、合計値をあらかじめ保存しておく<br>
- **ログテーブル**: 書き込み速度が重要で、後から更新しないデータ<br>
- **キャッシュテーブル**: 表示速度を上げるために、結合済みデータを保存<br>

**基本方針:**<br>
→ まず正規化する。パフォーマンスに問題が出たら、必要な部分だけ非正規化する。<br>

<div style="height:50px;"></div>

# まとめ

| 正規形 | ルール | ひとこと |
|--------|--------|---------|
| **第1正規形** | 1セル1データ | カンマ区切り禁止 |
| **第2正規形** | 主キー全体に依存させる | テーブルの責任を明確に |
| **第3正規形** | 主キー以外への依存を排除 | 間接的な依存も分離 |

**正規化の考え方を一言で言うと:**<br>
「このデータは本当にこのテーブルにあるべきか？」を突き詰める作業。<br>

<div style="height:50px;"></div>
